<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generalized Reconciliation Web App (Composite ID & Dupe Count)</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
    
    // --- ICON PLACEHOLDERS ---
    const IconWrapper = ({ children, size = 20, className = '', color = 'currentColor' }) => (
        <span className={className} style={{ width: size, height: size, display: 'inline-flex', alignItems: 'center', justifyContent: 'center', color: color }}>{children}</span>
    );
    const Upload = (props) => <IconWrapper {...props}><span role="img" aria-label="Upload">‚§í</span></IconWrapper>;
    const FileSpreadsheet = (props) => <IconWrapper {...props}><span role="img" aria-label="Spreadsheet">üìä</span></IconWrapper>;
    const AlertCircle = (props) => <IconWrapper {...props} color="rgb(234 88 12)"><span role="img" aria-label="Alert">‚ö†Ô∏è</span></IconWrapper>;
    const CheckCircle = (props) => <IconWrapper {...props} color="rgb(22 163 74)"><span role="img" aria-label="Check">‚úÖ</span></IconWrapper>;
    const Download = (props) => <IconWrapper {...props}><span role="img" aria-label="Download">‚¨áÔ∏è</span></IconWrapper>;
    const X = (props) => <IconWrapper {...props}><span role="img" aria-label="Close">‚úñÔ∏è</span></IconWrapper>;
    const Plus = (props) => <IconWrapper {...props}><span role="img" aria-label="Add">+</span></IconWrapper>;
    const Minus = (props) => <IconWrapper {...props}><span role="img" aria-label="Remove">-</span></IconWrapper>;
    // --- END ICON PLACEHOLDERS ---
    
    const { useState, useMemo } = React;

    /**
     * Helper function to extract a substring based on position, length, and start index.
     * @param {any} value - The raw cell value.
     * @param {string} position - 'Left', 'Right', or 'Middle'.
     * @param {number} length - Number of characters to extract.
     * @param {number} start - Start position (1-based) for 'Middle' extraction.
     * @returns {string} The extracted substring.
     */
    const extractValue = (value, position, length, start) => {
        if (value === null || value === undefined) return '';
        const str = String(value).trim();
        if (str.length === 0) return '';
        
        const len = parseInt(length) || str.length;
        
        switch (position) {
            case 'Left':
                return str.substring(0, len);
            case 'Right':
                return str.substring(str.length - len);
            case 'Middle':
                const startIndex = (parseInt(start) || 1) - 1; // Convert 1-based index to 0-based
                return str.substring(startIndex, startIndex + len);
            default:
                return str;
        }
    };
    
    /**
     * Generates the Unique_ID_Original (the concatenated base ID) from a row and configuration.
     * @param {object} row - The data row.
     * @param {Array<object>} config - The array of ID component configuration objects.
     * @returns {string} The concatenated unique ID base.
     */
    const generateCompositeIdBase = (row, config) => {
        const parts = config
            .filter(c => c.column && c.column !== '') 
            .map(c => {
                const value = row[c.column];
                return extractValue(value, c.position, c.length, c.start);
            });
            
        if (parts.length === 0) {
            return 'NO_ID_CONFIGURED'; 
        }
            
        // Concatenate parts with an underscore and convert to uppercase for standardization
        return parts.join('_').toUpperCase(); 
    };

    /**
     * Filters the final dataset to include only original columns and essential reconciliation metadata.
     * @param {Array<object>} data - The dataset (e.g., unmatchedA, matched).
     * @param {Array<string>} originalColsA - Original columns from Category A.
     * @param {Array<string>} originalColsB - Original columns from Category B.
     * @param {string} amountColA - Name of the amount column in A.
     * @param {string} amountColB - Name of the amount column in B.
     * @param {string} reportType - 'A', 'B', 'Matched', or 'Consolidated'.
     * @returns {Array<object>} Filtered data.
     */
    const filterOutputColumns = (data, originalColsA, originalColsB, amountColA, amountColB, reportType) => {
        
        const essentialCols = ['Source_File', 'Unique_ID_Original', 'Appearance_Count', 'Composite_ID', 'Match_Serial_No', 'Remark'];
        
        let colsToKeep = [];

        if (reportType === 'A') {
            // Keep original columns from A + essential cols
            colsToKeep = [...essentialCols, ...originalColsA];
        } else if (reportType === 'B') {
            // Keep original columns from B + essential cols
            colsToKeep = [...essentialCols, ...originalColsB];
        } else if (reportType === 'Matched') {
            // Keep original columns from A, original columns from B, all essential cols, and B's source file/amount
            const originalColsSet = new Set([...originalColsA, ...originalColsB]);
            colsToKeep = [...essentialCols, 'Source_File_B', ...Array.from(originalColsSet)];
        } else if (reportType === 'Consolidated') {
             // Keep original columns from A + B, essential cols + Category flag
            const originalColsSet = new Set([...originalColsA, ...originalColsB]);
            colsToKeep = ['Category', 'Source_File', 'Unique_ID_Original', 'Appearance_Count', ...Array.from(originalColsSet)];
        }


        // Remove duplicates and ensure a consistent order
        const uniqueCols = Array.from(new Set(colsToKeep));
        
        // Final mapping and formatting
        return data.map(row => {
            const newRow = {};
            uniqueCols.forEach(col => {
                // Special mapping for the amount columns to keep the original name but ensure it's present
                if (col === amountColA) {
                    newRow[`Amount_Category_A (${amountColA})`] = row.Amount;
                } else if (col === amountColB) {
                    newRow[`Amount_Category_B (${amountColB})`] = row.Amount_Category_B || row.Amount;
                } else {
                    newRow[col] = row[col];
                }
            });
            // Re-add Source_File_B if it's a matched report
            if (reportType === 'Matched' && row.Source_File_B) {
                 newRow['Source_File_B'] = row.Source_File_B;
            }
            return newRow;
        });
    };

    // Component for configuring one segment of the Unique ID
    const IdComponentForm = ({ config, setConfig, availableColumns, category }) => {
        const updateComponent = (id, field, value) => {
            setConfig(prev => prev.map(c => 
                c.id === id ? { ...c, [field]: value } : c
            ));
        };

        const addComponent = () => {
            setConfig(prev => [...prev, { id: Date.now(), column: '', position: 'Left', length: 5, start: 1 }]);
        };

        const removeComponent = (id) => {
            setConfig(prev => prev.filter(c => c.id !== id));
        };

        return (
            <div className="space-y-4">
                <h3 className="font-semibold text-lg text-indigo-700">Unique ID Components ({category})</h3>
                <p className="text-sm text-gray-600 italic">Combine characters from multiple columns to form the unique matching key, separated by '_'.</p>

                {config.map((c, index) => (
                    <div key={c.id} className="bg-white border border-indigo-200 p-4 rounded-lg shadow-sm space-y-3">
                        <div className="flex justify-between items-center border-b pb-2">
                             <span className="font-medium text-gray-700">Component {index + 1}</span>
                             {config.length > 1 && (
                                <button 
                                    onClick={() => removeComponent(c.id)} 
                                    className="text-red-500 hover:text-red-700 p-1 rounded-full bg-red-100 transition"
                                    title="Remove this component"
                                >
                                    <Minus size={16} />
                                </button>
                             )}
                        </div>
                        
                        <div className="grid grid-cols-1 md:grid-cols-4 gap-3">
                            <div>
                                <label className="block text-xs font-medium text-gray-700 mb-1">Source Column</label>
                                <select
                                    value={c.column}
                                    onChange={(e) => updateComponent(c.id, 'column', e.target.value)}
                                    className="w-full p-2 text-sm border border-gray-300 rounded-lg focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500"
                                >
                                    <option value="">Select Column</option>
                                    {availableColumns.map(col => (
                                        <option key={col} value={col}>{col}</option>
                                    ))}
                                </select>
                            </div>
                            
                            <div>
                                <label className="block text-xs font-medium text-gray-700 mb-1">Extraction Position</label>
                                <select
                                    value={c.position}
                                    onChange={(e) => updateComponent(c.id, 'position', e.target.value)}
                                    className="w-full p-2 text-sm border border-gray-300 rounded-lg focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500"
                                >
                                    <option value="Left">Left</option>
                                    <option value="Right">Right</option>
                                    <option value="Middle">Middle</option>
                                </select>
                            </div>
                            
                            <div>
                                <label className="block text-xs font-medium text-gray-700 mb-1">Length</label>
                                <input
                                    type="number"
                                    min="1"
                                    value={c.length}
                                    onChange={(e) => updateComponent(c.id, 'length', e.target.value)}
                                    className="w-full p-2 text-sm border border-gray-300 rounded-lg focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500"
                                    placeholder="Length"
                                />
                            </div>

                            {c.position === 'Middle' && (
                                <div>
                                    <label className="block text-xs font-medium text-gray-700 mb-1">Start (1-based)</label>
                                    <input
                                        type="number"
                                        min="1"
                                        value={c.start}
                                        onChange={(e) => updateComponent(c.id, 'start', e.target.value)}
                                        className="w-full p-2 text-sm border border-gray-300 rounded-lg focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500"
                                        placeholder="Start Index (1)"
                                    />
                                </div>
                            )}
                        </div>
                    </div>
                ))}

                <button 
                    onClick={addComponent}
                    className="flex items-center gap-1 px-3 py-1.5 text-sm bg-indigo-500 text-white rounded-lg hover:bg-indigo-600 transition"
                >
                    <Plus size={16} /> Add Component
                </button>
            </div>
        );
    };

    const ReconciliationApp = () => {
      const [step, setStep] = useState(1);
      const [categoryAFiles, setCategoryAFiles] = useState([]);
      const [categoryBFiles, setCategoryBFiles] = useState([]);
      
      const [columnConfig, setColumnConfig] = useState({
        amountA: '',
        amountB: ''
      });
      const [uniqueIdConfigA, setUniqueIdConfigA] = useState([{ id: 1, column: '', position: 'Left', length: 5, start: 1 }]);
      const [uniqueIdConfigB, setUniqueIdConfigB] = useState([{ id: 1, column: '', position: 'Left', length: 5, start: 1 }]);

      // Store original columns for filtering output
      const [originalColumnsA, setOriginalColumnsA] = useState([]);
      const [originalColumnsB, setOriginalColumnsB] = useState([]);
      const [availableColumnsA, setAvailableColumnsA] = useState([]);
      const [availableColumnsB, setAvailableColumnsB] = useState([]);
      
      const [processing, setProcessing] = useState(false);
      const [results, setResults] = useState(null);
      const [error, setError] = useState(null);

      const handleFileUpload = async (e, category) => {
        const files = Array.from(e.target.files);
        if (category === 'A') {
          setCategoryAFiles(prev => [...prev, ...files]);
          if (files.length > 0 && availableColumnsA.length === 0) {
            await extractColumns(files[0], setAvailableColumnsA, setOriginalColumnsA);
          }
        } else {
          setCategoryBFiles(prev => [...prev, ...files]);
          if (files.length > 0 && availableColumnsB.length === 0) {
            await extractColumns(files[0], setAvailableColumnsB, setOriginalColumnsB);
          }
        }
      };

      const extractColumns = async (file, setAvailableColumns, setOriginalColumns) => {
        try {
          const data = await file.arrayBuffer();
          const workbook = XLSX.read(data, { type: 'array' });
          
          const firstSheetName = workbook.SheetNames[0];
          const firstSheet = workbook.Sheets[firstSheetName];
          
          const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
          if (jsonData.length > 0) {
            const columns = jsonData[0].filter(col => col);
            setAvailableColumns(columns);
            setOriginalColumns(columns); // Store the full list of original columns
          }
        } catch (err) {
          console.error('Error reading file for columns:', err);
          setError(`Error reading columns from file '${file.name}'. Ensure the first sheet is properly formatted and contains headers.`);
        }
      };
      
      const removeFile = (index, category) => {
        if (category === 'A') {
          setCategoryAFiles(prev => prev.filter((_, i) => i !== index));
        } else {
          setCategoryBFiles(prev => prev.filter((_, i) => i !== index));
        }
      };

      const readExcelFiles = async (files) => {
        const allData = [];
        for (const file of files) {
          try {
            const data = await file.arrayBuffer();
            const workbook = XLSX.read(data, { type: 'array' });
            const firstSheetName = workbook.SheetNames[0];
            const firstSheet = workbook.Sheets[firstSheetName];
            
            const jsonData = XLSX.utils.sheet_to_json(firstSheet);
            jsonData.forEach(row => row.Source_File = file.name);
            allData.push(...jsonData);
          } catch (err) {
            console.error(`Error reading ${file.name} data:`, err);
            setError(`Critical: Failed to read data from '${file.name}'. Please check the file's integrity.`);
            return []; 
          }
        }
        return allData;
      };

      const isValidConfig = useMemo(() => {
          const isConfigAValid = uniqueIdConfigA.some(c => c.column && c.column !== '');
          const isConfigBValid = uniqueIdConfigB.some(c => c.column && c.column !== '');

          return isConfigAValid && isConfigBValid && columnConfig.amountA && columnConfig.amountB;
      }, [uniqueIdConfigA, uniqueIdConfigB, columnConfig.amountA, columnConfig.amountB]);


      const performReconciliation = async () => {
        setProcessing(true);
        setError(null);

        try {
          if (categoryAFiles.length === 0 || categoryBFiles.length === 0) {
            throw new Error('Please upload files for both categories');
          }
          if (!isValidConfig) {
            throw new Error('Please specify at least one column for the Unique ID for both categories, and select the Amount columns.');
          }

          const dataA = await readExcelFiles(categoryAFiles);
          const dataB = await readExcelFiles(categoryBFiles);

          if (dataA.length === 0 || dataB.length === 0) {
            throw new Error('No data found in uploaded files');
          }

          // --- 1. Standardization and Initial Processing ---
          const standardizeData = (data, idConfig, amountCol, categoryLabel) => {
            return data.map(row => {
                const uniqueIdBase = generateCompositeIdBase(row, idConfig);
                
                return {
                    Category: categoryLabel,
                    Unique_ID_Original: uniqueIdBase.trim().toUpperCase(), 
                    Amount: parseFloat(row[amountCol]) || 0,
                    Source_File: row.Source_File,
                    ...row
                };
            });
          };

          const standardizedA = standardizeData(dataA, uniqueIdConfigA, columnConfig.amountA, 'Category_A');
          const standardizedB = standardizeData(dataB, uniqueIdConfigB, columnConfig.amountB, 'Category_B');

          // --- 2. Calculate Duplication Count ---
          const checkDuplicates = (data) => {
            const idCounts = {};
            data.forEach(row => {
              const id = row.Unique_ID_Original;
              idCounts[id] = (idCounts[id] || 0) + 1;
            });
            // Add the count to each row
            return data.map(row => ({
              ...row,
              Appearance_Count: idCounts[row.Unique_ID_Original], // New column added here
              Is_Duplicated_Set: idCounts[row.Unique_ID_Original] > 1
            }));
          };

          let processedA = checkDuplicates(standardizedA);
          let processedB = checkDuplicates(standardizedB);
          
          // --- 3. Create Consolidated Report (before serialization) ---
          const consolidatedRecords = [...processedA, ...processedB];


          // --- 4. Serialization (1 for many, many for one) ---
          const addCompositeIds = (data) => {
            const serialMap = {};
            return data.map(row => {
              const id = row.Unique_ID_Original;
              serialMap[id] = (serialMap[id] || 0) + 1;
              return {
                ...row,
                Match_Serial_No: serialMap[id],
                // The final match key (e.g., ABC_123_1, ABC_123_2)
                Composite_ID: `${id}_${serialMap[id]}` 
              };
            });
          };

          processedA = addCompositeIds(processedA);
          processedB = addCompositeIds(processedB);

          // --- 5. Reconciliation (Outer Join Logic) ---
          const aMap = new Map(processedA.map(row => [row.Composite_ID, row]));
          const bMap = new Map(processedB.map(row => [row.Composite_ID, row]));

          const matched = [];
          const unmatchedA = [];
          const unmatchedB = [];

          processedA.forEach(rowA => {
            const rowB = bMap.get(rowA.Composite_ID);
            if (rowB) {
              const isExcess = rowA.Is_Duplicated_Set || rowB.Is_Duplicated_Set;
              matched.push({
                ...rowA,
                Amount_Category_B: rowB.Amount,
                Source_File_B: rowB.Source_File,
                Remark: isExcess ? 'Matched - Part of a 1:M or M:1 Set' : 'Matched - 1:1 Line Item'
              });
            } else {
              unmatchedA.push({
                ...rowA,
                Remark: rowA.Is_Duplicated_Set 
                    ? 'Unmatched in Record_Category_B (Part of a 1:M or M:1 Set in A)'
                    : 'Unmatched in Record_Category_B'
              });
            }
          });

          processedB.forEach(rowB => {
            if (!aMap.has(rowB.Composite_ID)) {
              unmatchedB.push({
                ...rowB,
                Remark: rowB.Is_Duplicated_Set 
                    ? 'Unmatched in Record_Category_A (Part of a 1:M or M:1 Set in B)'
                    : 'Unmatched in Record_Category_A'
              });
            }
          });

          // --- 6. Summary Report Generation (using totals from before serialization) ---
          const totalA = standardizedA.reduce((sum, row) => sum + row.Amount, 0);
          const totalB = standardizedB.reduce((sum, row) => sum + row.Amount, 0);
          const matchedAmountA = matched.reduce((sum, row) => sum + row.Amount, 0);
          const matchedAmountB = matched.reduce((sum, row) => sum + row.Amount_Category_B, 0);
          const unmatchedAmountA = unmatchedA.reduce((sum, row) => sum + row.Amount, 0);
          const unmatchedAmountB = unmatchedB.reduce((sum, row) => sum + row.Amount, 0);

          const summary = [
            // Category A Audit Block
            { Category: '1. Matched Items (Record_Category_A)', Count: matched.length, Amount: matchedAmountA },
            { Category: '2. Unmatched Items (Record_Category_A)', Count: unmatchedA.length, Amount: unmatchedAmountA },
            { Category: '3. Total Matched & Unmatched (A)', Count: matched.length + unmatchedA.length, Amount: matchedAmountA + unmatchedAmountA },
            { Category: '4. Total Consolidated Record_Category_A', Count: standardizedA.length, Amount: totalA }, // Use original count/amount
            { Category: '5. Category A Difference (4 minus 3)', Count: standardizedA.length - (matched.length + unmatchedA.length), Amount: totalA - (matchedAmountA + unmatchedAmountA) },
            // Category B Audit Block
            { Category: '6. Matched Items (Record_Category_B)', Count: matched.length, Amount: matchedAmountB },
            { Category: '7. Unmatched Items (Record_Category_B)', Count: unmatchedB.length, Amount: unmatchedAmountB },
            { Category: '8. Total Matched & Unmatched (B)', Count: matched.length + unmatchedB.length, Amount: matchedAmountB + unmatchedAmountB },
            { Category: '9. Total Consolidated Record_Category_B', Count: standardizedB.length, Amount: totalB }, // Use original count/amount
            { Category: '10. Category B Difference (9 minus 8)', Count: standardizedB.length - (matched.length + unmatchedB.length), Amount: totalB - (matchedAmountB + unmatchedAmountB) },
            // Overall Variance
            { Category: '11. Overall Variance (A Total - B Total)', Count: (totalA - totalB), Amount: totalA - totalB }
          ];

          setResults({ 
              summary, 
              matched, 
              unmatchedA, 
              unmatchedB,
              consolidatedRecords,
          });
          setStep(3);
        } catch (err) {
          setError(err.message);
          console.error('Reconciliation error:', err);
        } finally {
          setProcessing(false);
        }
      };

      const downloadResults = async () => {
        if (!results) return;

        try {
          const wb = XLSX.utils.book_new();
          
          // 1. Summary Report
          const summaryWS = XLSX.utils.json_to_sheet(results.summary);
          XLSX.utils.book_append_sheet(wb, summaryWS, 'Summary_Report');

          // 2. Consolidated Report (New Request)
          const consolidatedData = filterOutputColumns(
              results.consolidatedRecords, 
              originalColumnsA, 
              originalColumnsB, 
              columnConfig.amountA, 
              columnConfig.amountB, 
              'Consolidated'
          );
          const consolidatedWS = XLSX.utils.json_to_sheet(consolidatedData);
          XLSX.utils.book_append_sheet(wb, consolidatedWS, 'Consolidated_Records');
          
          // 3. Matched Report
          const matchedData = filterOutputColumns(
              results.matched, 
              originalColumnsA, 
              originalColumnsB, 
              columnConfig.amountA, 
              columnConfig.amountB, 
              'Matched'
          );
          const matchedWS = XLSX.utils.json_to_sheet(matchedData);
          XLSX.utils.book_append_sheet(wb, matchedWS, 'Matched_Report');
          
          // 4. Unmatched Category A Report
          const unmatchedAData = filterOutputColumns(
              results.unmatchedA, 
              originalColumnsA, 
              originalColumnsB, 
              columnConfig.amountA, 
              columnConfig.amountB, 
              'A'
          );
          const unmatchedAWS = XLSX.utils.json_to_sheet(unmatchedAData);
          XLSX.utils.book_append_sheet(wb, unmatchedAWS, 'Unmatched_Category_A');
          
          // 5. Unmatched Category B Report
          const unmatchedBData = filterOutputColumns(
              results.unmatchedB, 
              originalColumnsA, 
              originalColumnsB, 
              columnConfig.amountA, 
              columnConfig.amountB, 
              'B'
          );
          const unmatchedBWS = XLSX.utils.json_to_sheet(unmatchedBData);
          XLSX.utils.book_append_sheet(wb, unmatchedBWS, 'Unmatched_Category_B');
          
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
          XLSX.writeFile(wb, `Reconciliation_Report_${timestamp}.xlsx`);
        } catch (err) {
          setError('Error generating Excel file: ' + err.message);
          console.error('Download error:', err);
        }
      };

      const resetApp = () => {
        setStep(1);
        setCategoryAFiles([]);
        setCategoryBFiles([]);
        setColumnConfig({ amountA: '', amountB: '' });
        setUniqueIdConfigA([{ id: 1, column: '', position: 'Left', length: 5, start: 1 }]);
        setUniqueIdConfigB([{ id: 1, column: '', position: 'Left', length: 5, start: 1 }]);
        setAvailableColumnsA([]);
        setAvailableColumnsB([]);
        setOriginalColumnsA([]);
        setOriginalColumnsB([]);
        setResults(null);
        setError(null);
      };

      return (
        <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-6">
          <div className="max-w-7xl mx-auto">
            <div className="bg-white rounded-lg shadow-xl p-8">
              <h1 className="text-3xl font-bold text-gray-800 mb-2">Advanced Records Reconciliation Tool</h1>
              <p className="text-gray-600 mb-6">Create a composite Unique ID from multiple column fragments to enable precise 1:1 matching and handle 1:M/M:1 serialization.</p>

              <div className="flex items-center justify-between mb-8">
                {[1, 2, 3].map((s) => (
                  <div key={s} className="flex items-center flex-1">
                    <div className={`w-10 h-10 rounded-full flex items-center justify-center font-bold ${
                      step >= s ? 'bg-indigo-600 text-white' : 'bg-gray-300 text-gray-600'
                    }`}>
                      {s}
                    </div>
                    {s < 3 && <div className={`flex-1 h-1 mx-2 ${step > s ? 'bg-indigo-600' : 'bg-gray-300'}`} />}
                  </div>
                ))}
              </div>

              {error && (
                <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6 flex items-start">
                  <AlertCircle className="text-red-600 mr-3 flex-shrink-0 mt-0.5" size={20} />
                  <div>
                    <h3 className="font-semibold text-red-800">Error</h3>
                    <p className="text-red-700">{error}</p>
                  </div>
                </div>
              )}

              {step === 1 && (
                <div className="space-y-6">
                  <div>
                    <h2 className="text-xl font-semibold mb-4">Step 1: Upload Excel Files</h2>
                    
                    <div className="grid md:grid-cols-2 gap-6">
                      <div className="border-2 border-dashed border-gray-300 rounded-lg p-6 hover:border-indigo-400 transition">
                        <h3 className="font-semibold text-lg mb-3 text-indigo-700">Record Category A</h3>
                        <label className="cursor-pointer block">
                          <input
                            type="file"
                            multiple
                            accept=".xlsx,.xls"
                            onChange={(e) => handleFileUpload(e, 'A')}
                            className="hidden"
                          />
                          <div className="flex flex-col items-center py-6 text-gray-600">
                            <Upload size={48} className="mb-3 text-indigo-500" />
                            <p className="font-medium">Click to upload
