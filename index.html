<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Reconciliation Tool (Selective ID/Amount/Output Columns)</title>
    <!-- Load React and ReactDOM from CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Load Babel for JSX transpilation in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load SheetJS/XLSX for Excel file handling -->
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
    <style>
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            border-radius: 0.5rem;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen font-sans">
    <div id="root"></div>

    <script type="text/babel">
    // Destructure hooks from the global React object for easy access
    const { useState, useEffect, useCallback, useMemo } = React;
    
    // --- ICON PLACEHOLDERS ---
    const IconWrapper = ({ children, size = 20, className = '', color = 'currentColor' }) => (
        <span className={className} style={{ width: size, height: size, display: 'inline-flex', alignItems: 'center', justifyContent: 'center', color: color }}>{children}</span>
    );
    const Upload = (props) => <IconWrapper {...props}><span role="img" aria-label="Upload">‚§í</span></IconWrapper>;
    const FileSpreadsheet = (props) => <IconWrapper {...props}><span role="img" aria-label="Spreadsheet">üßæ</span></IconWrapper>;
    const Info = (props) => <IconWrapper {...props}><span role="img" aria-label="Info">‚ÑπÔ∏è</span></IconWrapper>;
    const Check = (props) => <IconWrapper {...props}><span role="img" aria-label="Check">‚úîÔ∏è</span></IconWrapper>;
    const Download = (props) => <IconWrapper {...props}><span role="img" aria-label="Download">‚¨áÔ∏è</span></IconWrapper>;
    const Loader2 = (props) => <IconWrapper {...props}><span className="animate-spin" role="img" aria-label="Loading">üîÑ</span></IconWrapper>;
    
    // --- Initial State and Constants ---
    const initialState = { name: null, headers: [], data: [], idCol: null, amountCol: null };
    const initialResults = {
        A_Matched: [], A_Unmatched: [], 
        B_Matched: [], B_Unmatched: [],
        summary: []
    };
    
    const downloadOptions = [
        { key: 'summary', name: 'Summary Report (Metrics)', filename: 'Reconciliation_Summary.xlsx' },
        { key: 'a_matched', name: 'A Matched (Detailed)', filename: 'A_Matched.xlsx' },
        { key: 'a_unmatched', name: 'A Unmatched (Detailed)', filename: 'A_Unmatched.xlsx' },
        { key: 'b_matched', name: 'B Matched (Detailed)', filename: 'B_Matched.xlsx' },
        { key: 'b_unmatched', name: 'B Unmatched (Detailed)', filename: 'B_Unmatched.xlsx' },
    ];
    
    // --- Helper Functions ---

    /**
     * Parses an uploaded file (Excel/CSV) using SheetJS.
     * @param {File} file The file object.
     * @returns {Promise<{name: string, headers: string[], data: object[]}>}
     */
    const parseFile = (file) => {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    // Read data into an array of objects, keeping header names as they are
                    const json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                    
                    if (json.length === 0) {
                        return reject(new Error("File is empty or contains no data."));
                    }

                    // The first row is the header
                    const headers = json[0].map(h => String(h).trim()).filter(h => h.length > 0);
                    // Subsequent rows are data
                    const rawData = json.slice(1);
                    
                    const processedData = rawData.map((row, index) => {
                        const rowObj = {};
                        headers.forEach((header, i) => {
                            // Assign value, handling undefined/null cells
                            rowObj[header] = row[i] !== undefined ? row[i] : null; 
                        });
                        // Add traceability data
                        rowObj.__Source_File = file.name;
                        rowObj.__Original_Row_Index = index + 2; // +1 for 0-index to 1-index, +1 for header row
                        return rowObj;
                    }).filter(row => Object.keys(row).some(key => key.startsWith('__') === false && row[key] !== null)); // Filter out completely empty rows

                    if (processedData.length === 0) {
                         return reject(new Error("No valid data rows found after processing."));
                    }

                    resolve({
                        name: file.name,
                        headers: headers,
                        data: processedData,
                    });

                } catch (error) {
                    console.error("File parsing error:", error);
                    reject(new Error(`Failed to parse file: ${error.message}`));
                }
            };
            reader.onerror = (error) => reject(new Error(`File read error: ${error.message}`));
            reader.readAsArrayBuffer(file);
        });
    };

    /**
     * Converts an array of objects to a sheet and downloads it as an Excel file.
     */
    const downloadExcel = (data, headers, filename) => {
        if (!data || data.length === 0) {
            console.error("No data to download for", filename);
            return;
        }

        const filteredData = data.map(row => {
            const newRow = {};
            // Only include headers that exist in the row (important for optional traceability columns)
            headers.forEach(header => {
                if (row.hasOwnProperty(header)) {
                    newRow[header] = row[header];
                }
            });
            return newRow;
        });

        const worksheet = XLSX.utils.json_to_sheet(filteredData, { header: headers });
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, "Report");
        XLSX.writeFile(workbook, filename);
    };

    // --- Components ---

    const FileUploadCard = ({ category, fileData, setFileData, setError, setIsLoading, maxFiles }) => {
        const handleFileChange = async (event) => {
            setError(null);
            const file = event.target.files[0];
            if (!file) return;

            setIsLoading(true);
            try {
                const result = await parseFile(file);
                // Preserve existing column selections if headers are the same
                setFileData(prev => ({
                    ...prev,
                    name: result.name,
                    headers: result.headers,
                    data: result.data,
                    // Reset ID/Amount columns if file changes, as headers might be different
                    idCol: null, 
                    amountCol: null,
                }));
            } catch (err) {
                setError(`Error loading ${category}: ${err.message}`);
                setFileData(initialState);
            } finally {
                setIsLoading(false);
            }
        };

        return (
            <div className="bg-white p-6 rounded-xl shadow-lg border border-gray-200 flex flex-col">
                <h2 className="text-xl font-bold text-gray-800 mb-3">{category}</h2>
                <input 
                    type="file" 
                    accept=".xlsx,.xls,.csv" 
                    id={`file-upload-${category}`} 
                    onChange={handleFileChange} 
                    className="hidden" 
                />
                
                {fileData.name ? (
                    <div className="flex items-center justify-between p-3 bg-green-50 border border-green-200 rounded-lg">
                        <span className="text-sm font-medium text-green-800 flex items-center">
                            <Check size={16} className="mr-2" />
                            File Loaded: {fileData.name} ({fileData.data.length} rows)
                        </span>
                        <button 
                            onClick={() => setFileData(initialState)}
                            className="text-xs text-red-600 hover:text-red-800 font-semibold"
                        >
                            Remove
                        </button>
                    </div>
                ) : (
                    <label 
                        htmlFor={`file-upload-${category}`} 
                        className="cursor-pointer flex items-center justify-center p-4 border-2 border-dashed border-indigo-300 rounded-lg text-indigo-600 hover:bg-indigo-50 transition duration-150"
                    >
                        <Upload size={20} className="mr-2" />
                        Upload {category} File (.xlsx, .csv)
                    </label>
                )}
            </div>
        );
    };

    const ColumnSelector = ({ category, headers, selectedCol, onSelect, label, id, isRequired = true }) => (
        <div className="mb-4">
            <label htmlFor={id} className="block text-sm font-medium text-gray-700 mb-1">
                {label} ({category}) {isRequired && <span className="text-red-500">*</span>}
            </label>
            <select
                id={id}
                value={selectedCol || ''}
                onChange={(e) => onSelect(e.target.value)}
                className="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 bg-white"
                required={isRequired}
                disabled={headers.length === 0}
            >
                <option value="" disabled>{headers.length > 0 ? 'Select a column' : 'Upload file first'}</option>
                {headers.map(header => (
                    <option key={header} value={header}>{header}</option>
                ))}
            </select>
        </div>
    );
    
    const MultiColumnSelector = ({ allHeaders, selectedHeaders, onToggle }) => {
        const uniqueHeaders = useMemo(() => {
            const set = new Set(allHeaders);
            return Array.from(set).sort();
        }, [allHeaders]);
    
        return (
            <div className="mb-6 bg-white p-4 rounded-lg border border-gray-200 h-96 overflow-y-auto">
                <label className="block text-sm font-bold text-gray-800 mb-3 sticky top-0 bg-white pb-2 z-10">
                    Select Output Columns for Detailed Reports <span className="text-red-500">*</span>
                    <p className="text-xs font-normal text-gray-500 mt-1">
                        Select the data columns you wish to include in the A Matched/Unmatched and B Matched/Unmatched reports.
                    </p>
                </label>
                <div className="space-y-2">
                    {uniqueHeaders.map(header => (
                        <div key={header} className="flex items-center">
                            <input
                                id={`output-col-${header}`}
                                type="checkbox"
                                checked={selectedHeaders.includes(header)}
                                onChange={() => onToggle(header)}
                                className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                            />
                            <label 
                                htmlFor={`output-col-${header}`} 
                                className="ml-3 text-sm font-medium text-gray-700 break-words"
                            >
                                {header}
                            </label>
                        </div>
                    ))}
                </div>
                {uniqueHeaders.length === 0 && (
                    <p className="text-sm text-gray-500 mt-2">Upload both files to see available columns.</p>
                )}
            </div>
        );
    };

    const SummaryTable = ({ category, metrics }) => {
        if (!metrics) return null;
        
        const data = [
            { label: `Total Consolidated ${category}`, count: metrics.totalConsolidatedCount, amount: metrics.totalConsolidatedAmount, color: 'bg-gray-100 font-bold' },
            { label: `${category} Matched`, count: metrics.matchedCount, amount: metrics.matchedAmount, color: 'bg-green-50' },
            { label: `${category} Unmatched`, count: metrics.unmatchedCount, amount: metrics.unmatchedAmount, color: 'bg-red-50' },
        ];

        return (
            <div className="p-4 bg-white rounded-xl shadow-md border border-gray-100">
                <h4 className="text-lg font-semibold mb-3 text-gray-800">{category} Metrics</h4>
                <div className="overflow-x-auto">
                    <table className="min-w-full divide-y divide-gray-200">
                        <thead className="bg-gray-50">
                            <tr>
                                <th className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Metric</th>
                                <th className="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Count</th>
                                <th className="px-3 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Total Amount</th>
                            </tr>
                        </thead>
                        <tbody className="bg-white divide-y divide-gray-200">
                            {data.map((row, index) => (
                                <tr key={index} className={row.color}>
                                    <td className="px-3 py-2 whitespace-nowrap text-sm text-gray-900">{row.label}</td>
                                    <td className="px-3 py-2 whitespace-nowrap text-sm text-right font-mono text-gray-800">{row.count.toLocaleString()}</td>
                                    <td className="px-3 py-2 whitespace-nowrap text-sm text-right font-mono text-gray-800">{row.amount.toFixed(2).toLocaleString()}</td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            </div>
        );
    };

    // --- Main Application Logic ---

    const ReconciliationApp = () => {
        const [step, setStep] = useState(1); // 1: Upload, 2: Configure, 3: Results
        const [fileDataA, setFileDataA] = useState(initialState);
        const [fileDataB, setFileDataB] = useState(initialState);
        const [results, setResults] = useState(null);
        const [error, setError] = useState(null);
        const [isLoading, setIsLoading] = useState(false);
        const [selectedOutputHeaders, setSelectedOutputHeaders] = useState([]);
        const [selectedDownloads, setSelectedDownloads] = useState(downloadOptions.map(opt => opt.key));

        // Get all unique headers from both files for the output selector
        const allUniqueHeaders = useMemo(() => {
            const allHeaders = [...fileDataA.headers, ...fileDataB.headers];
            return Array.from(new Set(allHeaders)).sort();
        }, [fileDataA.headers, fileDataB.headers]);
        
        // Auto-select all unique headers when files change
        useEffect(() => {
            if (fileDataA.headers.length > 0 && fileDataB.headers.length > 0) {
                const uniqueHeaders = Array.from(new Set([...fileDataA.headers, ...fileDataB.headers]));
                // Keep only the headers that are present in the new set of unique headers
                setSelectedOutputHeaders(prev => {
                    const filtered = prev.filter(h => uniqueHeaders.includes(h));
                    if (filtered.length !== uniqueHeaders.length) {
                        return uniqueHeaders; // If headers changed, select all again
                    }
                    return filtered;
                });
            } else {
                setSelectedOutputHeaders([]);
            }
        }, [fileDataA.headers, fileDataB.headers]);

        const toggleOutputHeader = (header) => {
            setSelectedOutputHeaders(prev => {
                if (prev.includes(header)) {
                    return prev.filter(h => h !== header);
                } else {
                    return [...prev, header];
                }
            });
        };

        const performReconciliation = useCallback(() => {
            setError(null);
            setIsLoading(true);
            
            // Validate required columns
            if (!fileDataA.idCol || !fileDataA.amountCol || !fileDataB.idCol || !fileDataB.amountCol || selectedOutputHeaders.length === 0) {
                setError("Please select all required ID, Amount, and Output columns.");
                setIsLoading(false);
                return;
            }

            // Use setTimeout to allow the UI to update with the loading state
            setTimeout(() => {
                try {
                    const dataA = fileDataA.data;
                    const dataB = fileDataB.data;
                    const idColA = fileDataA.idCol;
                    const amountColA = fileDataA.amountCol;
                    const idColB = fileDataB.idCol;
                    const amountColB = fileDataB.amountCol;

                    const A_Matched = [];
                    const A_Unmatched = [];
                    const B_Matched = [];
                    const B_Unmatched = [];

                    // 1. Process A and build a B-lookup map
                    const B_lookup = new Map();
                    let totalBCount = 0;
                    let totalBAmount = 0;
                    
                    dataB.forEach(row => {
                        const id = String(row[idColB]).trim().toUpperCase();
                        const amount = Number(row[amountColB]) || 0;
                        totalBCount++;
                        totalBAmount += amount;

                        if (!B_lookup.has(id)) {
                            B_lookup.set(id, []);
                        }
                        // Add traceability info and appearance count
                        row.__Composite_ID = id;
                        B_lookup.get(id).push(row);
                    });

                    // 2. Reconcile A against B
                    let totalACount = 0;
                    let totalAAmount = 0;
                    const matchedBIds = new Set();
                    
                    dataA.forEach(row => {
                        const id = String(row[idColA]).trim().toUpperCase();
                        const amount = Number(row[amountColA]) || 0;
                        totalACount++;
                        totalAAmount += amount;
                        
                        row.__Composite_ID = id;

                        if (B_lookup.has(id)) {
                            A_Matched.push(row);
                            // Mark all B rows with this ID as matched
                            B_lookup.get(id).forEach(bRow => matchedBIds.add(bRow.__Composite_ID));
                        } else {
                            A_Unmatched.push(row);
                        }
                    });

                    // 3. Determine B Matched/Unmatched lists
                    dataB.forEach(row => {
                        // The Composite_ID was added in step 1
                        if (matchedBIds.has(row.__Composite_ID)) {
                            B_Matched.push(row);
                        } else {
                            B_Unmatched.push(row);
                        }
                    });

                    // 4. Calculate Summary Metrics
                    const calculateMetrics = (data, amountCol) => {
                        const amount = data.reduce((sum, row) => sum + (Number(row[amountCol]) || 0), 0);
                        return {
                            count: data.length,
                            amount: amount,
                        };
                    };
                    
                    const A_MatchedMetrics = calculateMetrics(A_Matched, amountColA);
                    const A_UnmatchedMetrics = calculateMetrics(A_Unmatched, amountColA);
                    const B_MatchedMetrics = calculateMetrics(B_Matched, amountColB);
                    const B_UnmatchedMetrics = calculateMetrics(B_Unmatched, amountColB);

                    const summaryMetricsA = {
                        totalConsolidatedCount: totalACount,
                        totalConsolidatedAmount: totalAAmount,
                        matchedCount: A_MatchedMetrics.count,
                        matchedAmount: A_MatchedMetrics.amount,
                        unmatchedCount: A_UnmatchedMetrics.count,
                        unmatchedAmount: A_UnmatchedMetrics.amount,
                    };

                    const summaryMetricsB = {
                        totalConsolidatedCount: totalBCount,
                        totalConsolidatedAmount: totalBAmount,
                        matchedCount: B_MatchedMetrics.count,
                        matchedAmount: B_MatchedMetrics.amount,
                        unmatchedCount: B_UnmatchedMetrics.count,
                        unmatchedAmount: B_UnmatchedMetrics.amount,
                    };
                    
                    // 5. Create Summary Report Data (for download)
                    const summaryReportData = [
                        { Metric: `Total Consolidated A (${fileDataA.name})`, Count: summaryMetricsA.totalConsolidatedCount, 'Total Amount': summaryMetricsA.totalConsolidatedAmount },
                        { Metric: 'A Matched', Count: summaryMetricsA.matchedCount, 'Total Amount': summaryMetricsA.matchedAmount },
                        { Metric: 'A Unmatched', Count: summaryMetricsA.unmatchedCount, 'Total Amount': summaryMetricsA.unmatchedAmount },
                        { Metric: `Total Consolidated B (${fileDataB.name})`, Count: summaryMetricsB.totalConsolidatedCount, 'Total Amount': summaryMetricsB.totalConsolidatedAmount },
                        { Metric: 'B Matched', Count: summaryMetricsB.matchedCount, 'Total Amount': summaryMetricsB.matchedAmount },
                        { Metric: 'B Unmatched', Count: summaryMetricsB.unmatchedCount, 'Total Amount': summaryMetricsB.unmatchedAmount },
                    ];

                    setResults({
                        A_Matched, A_Unmatched, B_Matched, B_Unmatched,
                        summary: summaryReportData,
                        summaryMetricsA, summaryMetricsB
                    });
                    setStep(3);

                } catch (err) {
                    setError(`Reconciliation failed: ${err.message}`);
                } finally {
                    setIsLoading(false);
                }
            }, 50); // Small delay for UI update
        }, [fileDataA, fileDataB, selectedOutputHeaders]);
        
        const downloadReports = useCallback(() => {
            if (!results) {
                setError("No results generated yet.");
                return;
            }

            const baseHeaders = ['__Composite_ID', '__Source_File', '__Original_Row_Index'];
            const fileKeyMap = {
                summary: { data: results.summary, headers: ['Metric', 'Count', 'Total Amount'] },
                a_matched: { 
                    data: results.A_Matched, 
                    headers: [...baseHeaders, ...selectedOutputHeaders.filter(h => fileDataA.headers.includes(h))]
                },
                a_unmatched: { 
                    data: results.A_Unmatched, 
                    headers: [...baseHeaders, ...selectedOutputHeaders.filter(h => fileDataA.headers.includes(h))]
                },
                b_matched: { 
                    data: results.B_Matched, 
                    headers: [...baseHeaders, ...selectedOutputHeaders.filter(h => fileDataB.headers.includes(h))]
                },
                b_unmatched: { 
                    data: results.B_Unmatched, 
                    headers: [...baseHeaders, ...selectedOutputHeaders.filter(h => fileDataB.headers.includes(h))]
                },
            };

            const reportsToDownload = downloadOptions.filter(opt => selectedDownloads.includes(opt.key));

            if (reportsToDownload.length === 0) {
                setError("Please select at least one report to download.");
                return;
            }

            reportsToDownload.forEach(report => {
                const dataConfig = fileKeyMap[report.key];
                if (dataConfig.data && dataConfig.data.length > 0) {
                    downloadExcel(dataConfig.data, dataConfig.headers, report.filename);
                } else if (report.key === 'summary') {
                     downloadExcel(dataConfig.data, dataConfig.headers, report.filename); // Summary always has data
                } else {
                    console.warn(`Skipping download for ${report.name}: No data generated.`);
                    // Generate file with only headers if no data
                    downloadExcel([], dataConfig.headers, report.filename);
                }
            });

        }, [results, selectedDownloads, selectedOutputHeaders, fileDataA.headers, fileDataB.headers]);
        
        // --- Step Components ---

        const UploadStep = () => (
            <>
                <h1 className="text-3xl font-extrabold text-gray-900 mb-6 text-center">Step 1: Upload Data Files</h1>
                <div className="grid md:grid-cols-2 gap-6 mb-8">
                    <FileUploadCard 
                        category="Category A" 
                        fileData={fileDataA} 
                        setFileData={setFileDataA} 
                        setError={setError} 
                        setIsLoading={setIsLoading} 
                    />
                    <FileUploadCard 
                        category="Category B" 
                        fileData={fileDataB} 
                        setFileData={setFileDataB} 
                        setError={setError} 
                        setIsLoading={setIsLoading} 
                    />
                </div>
                
                <div className="text-center">
                    <button
                        onClick={() => setStep(2)}
                        disabled={!fileDataA.name || !fileDataB.name}
                        className={`px-8 py-3 rounded-xl font-bold transition duration-300 ${
                            !fileDataA.name || !fileDataB.name
                                ? 'bg-indigo-300 text-white cursor-not-allowed'
                                : 'bg-indigo-600 hover:bg-indigo-700 text-white shadow-lg'
                        }`}
                    >
                        Proceed to Column Selection (Step 2)
                    </button>
                </div>
            </>
        );

        const ColumnSelectionStep = () => {
            const isReady = fileDataA.idCol && fileDataA.amountCol && fileDataB.idCol && fileDataB.amountCol && selectedOutputHeaders.length > 0;
            
            return (
                <form 
                    onSubmit={(e) => { e.preventDefault(); performReconciliation(); }}
                    className="space-y-6"
                >
                    <h1 className="text-3xl font-extrabold text-gray-900 mb-4 text-center">Step 2: Configure Reconciliation</h1>
                    
                    <div className="grid lg:grid-cols-3 gap-6 bg-gray-100 p-6 rounded-xl shadow-inner">
                        {/* Category A Column Selectors */}
                        <div className="lg:col-span-1 bg-white p-5 rounded-lg border border-gray-200 shadow-md">
                            <h2 className="text-xl font-bold text-indigo-700 mb-4">Category A ({fileDataA.name})</h2>
                            <ColumnSelector
                                category="Category A"
                                headers={fileDataA.headers}
                                selectedCol={fileDataA.idCol}
                                onSelect={(col) => setFileDataA(prev => ({ ...prev, idCol: col }))}
                                label="Unique ID Column (Matching Key)"
                                id="id-a"
                            />
                            <ColumnSelector
                                category="Category A"
                                headers={fileDataA.headers}
                                selectedCol={fileDataA.amountCol}
                                onSelect={(col) => setFileDataA(prev => ({ ...prev, amountCol: col }))}
                                label="Amount Column (For Aggregation)"
                                id="amount-a"
                            />
                        </div>

                        {/* Category B Column Selectors */}
                        <div className="lg:col-span-1 bg-white p-5 rounded-lg border border-gray-200 shadow-md">
                            <h2 className="text-xl font-bold text-pink-700 mb-4">Category B ({fileDataB.name})</h2>
                            <ColumnSelector
                                category="Category B"
                                headers={fileDataB.headers}
                                selectedCol={fileDataB.idCol}
                                onSelect={(col) => setFileDataB(prev => ({ ...prev, idCol: col }))}
                                label="Unique ID Column (Matching Key)"
                                id="id-b"
                            />
                            <ColumnSelector
                                category="Category B"
                                headers={fileDataB.headers}
                                selectedCol={fileDataB.amountCol}
                                onSelect={(col) => setFileDataB(prev => ({ ...prev, amountCol: col }))}
                                label="Amount Column (For Aggregation)"
                                id="amount-b"
                            />
                        </div>
                        
                        {/* Output Column Selector */}
                        <div className="lg:col-span-1">
                            <MultiColumnSelector
                                allHeaders={allUniqueHeaders}
                                selectedHeaders={selectedOutputHeaders}
                                onToggle={toggleOutputHeader}
                            />
                        </div>
                    </div>

                    <div className="flex justify-between items-center pt-4">
                        <button
                            type="button"
                            onClick={() => setStep(1)}
                            className="px-6 py-3 border border-gray-300 text-gray-700 font-semibold rounded-lg hover:bg-gray-100 transition duration-200"
                        >
                            ‚Üê Back to Upload
                        </button>
                        
                        <button
                            type="submit"
                            disabled={!isReady || isLoading}
                            className={`px-8 py-3 rounded-xl font-bold transition duration-300 flex items-center justify-center ${
                                !isReady || isLoading
                                    ? 'bg-indigo-300 text-white cursor-not-allowed'
                                    : 'bg-indigo-600 hover:bg-indigo-700 text-white shadow-lg'
                            }`}
                        >
                            {isLoading ? (
                                <>
                                    <Loader2 size={20} className="mr-2" />
                                    Reconciling...
                                </>
                            ) : (
                                "Run Reconciliation (Step 3)"
                            )}
                        </button>
                    </div>
                </form>
            );
        };

        const ResultStep = () => (
            <div className="space-y-8">
                <h1 className="text-3xl font-extrabold text-gray-900 text-center">Reconciliation Complete!</h1>
                
                {/* Download Options */}
                <div className="bg-white p-6 rounded-xl shadow-lg border border-gray-200">
                    <h2 className="text-2xl font-bold text-gray-800 mb-4 flex items-center">
                        <Download size={24} className="mr-2 text-indigo-600" />
                        Select Reports to Download (Separate Excel Files)
                    </h2>
                    
                    <div className="grid sm:grid-cols-2 md:grid-cols-3 gap-4 mb-6">
                        {downloadOptions.map(option => (
                            <div key={option.key} className="flex items-center">
                                <input
                                    id={`download-${option.key}`}
                                    type="checkbox"
                                    checked={selectedDownloads.includes(option.key)}
                                    onChange={() => {
                                        setSelectedDownloads(prev => 
                                            prev.includes(option.key)
                                                ? prev.filter(k => k !== option.key)
                                                : [...prev, option.key]
                                        );
                                    }}
                                    className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                                />
                                <label htmlFor={`download-${option.key}`} className="ml-3 text-sm font-medium text-gray-700">
                                    {option.name}
                                </label>
                            </div>
                        ))}
                    </div>

                    <button
                        onClick={downloadReports}
                        disabled={selectedDownloads.length === 0}
                        className={`w-full px-8 py-3 rounded-xl font-bold transition duration-300 flex items-center justify-center ${
                            selectedDownloads.length === 0
                                ? 'bg-gray-300 text-gray-600 cursor-not-allowed'
                                : 'bg-green-600 hover:bg-green-700 text-white shadow-lg'
                        }`}
                    >
                        <Download size={20} className="mr-2" />
                        Download {selectedDownloads.length} Selected Report{selectedDownloads.length !== 1 ? 's' : ''}
                    </button>
                </div>


                {/* Structured Summary Tables */}
                <div className="bg-gray-100 rounded-xl p-6 shadow-inner">
                    <h3 className="font-bold text-2xl mb-6 text-gray-800 border-b pb-3">Key Summary Metrics</h3>
                    <div className="grid lg:grid-cols-2 gap-6">
                        {/* Category A Summary */}
                        <SummaryTable metrics={results.summaryMetricsA} category="Category A" />
                        
                        {/* Category B Summary */}
                        <SummaryTable metrics={results.summaryMetricsB} category="Category B" />
                    </div>
                </div>

                <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                    <p className="text-sm text-blue-800 flex items-start">
                        <Info size={18} className="mr-2 mt-0.5 flex-shrink-0 text-blue-600" />
                        <span>
                            **Traceability Note:** All generated data sheets include the **`__Composite_ID`** (the key used for matching), **`__Source_File`**, and **`__Original_Row_Index`** (the exact row number in the source file) columns for traceability back to the origin.
                        </span>
                    </p>
                </div>

                <div className="text-center pt-4">
                    <button 
                        onClick={() => { 
                            setStep(1); 
                            setResults(null); 
                            setFileDataA(initialState); 
                            setFileDataB(initialState);
                            setSelectedOutputHeaders([]);
                            setSelectedDownloads(downloadOptions.map(opt => opt.key));
                        }} 
                        className="px-6 py-3 border border-gray-300 text-gray-700 font-semibold rounded-lg hover:bg-gray-100 transition duration-200"
                    >
                        Start New Reconciliation
                    </button>
                </div>
            </div>
        );

        // --- Main Render ---
        return (
            <div className="container mx-auto p-4 md:p-8">
                <div className="max-w-4xl mx-auto relative">
                    {/* Main Content Card */}
                    <div className="bg-white p-6 md:p-10 rounded-xl shadow-2xl">
                        
                        {/* Loading Overlay */}
                        {isLoading && (
                            <div className="loading-overlay">
                                <div className="flex flex-col items-center">
                                    <Loader2 size={48} className="text-indigo-600 mb-3" />
                                    <p className="text-lg font-semibold text-gray-700">Processing Data...</p>
                                    <p className="text-sm text-gray-500">Please wait, reconciliation is in progress.</p>
                                </div>
                            </div>
                        )}

                        {/* Error Message */}
                        {error && (
                            <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-6 rounded-lg" role="alert">
                                <p className="font-bold">Error</p>
                                <p>{error}</p>
                            </div>
                        )}
                        
                        {/* Step Navigation */}
                        <div className="mb-8 flex justify-center space-x-2">
                            {[1, 2, 3].map(s => (
                                <div 
                                    key={s} 
                                    className={`w-1/3 py-2 text-center text-sm font-medium rounded-full transition duration-300 ${
                                        s === step 
                                            ? 'bg-indigo-600 text-white shadow-md' 
                                            : s < step 
                                                ? 'bg-indigo-200 text-indigo-700 cursor-pointer'
                                                : 'bg-gray-200 text-gray-500'
                                    }`}
                                    onClick={() => s < step ? setStep(s) : null}
                                >
                                    Step {s}: {s === 1 ? 'Upload' : s === 2 ? 'Columns' : 'Results'}
                                </div>
                            ))}
                        </div>

                        {/* Current Step Content */}
                        {step === 1 && <UploadStep />}
                        {step === 2 && <ColumnSelectionStep />}
                        {step === 3 && results && <ResultStep />}
                    </div>
                </div>
            </div>
        );
    };
    
    // Render the React application
    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    root.render(<ReconciliationApp />);

    </script>
</body>
</html>
