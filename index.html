<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Reconciliation Tool (Single Consolidated Report)</title>
    <!-- Load React and ReactDOM from CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Load Babel for JSX transpilation in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load SheetJS/XLSX for Excel file handling -->
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
    <style>
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            border-radius: 0.5rem;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen font-sans">
    <div id="root"></div>

    <script type="text/babel">
    // Destructure hooks from the global React object for easy access
    const { useState, useEffect, useCallback, useMemo } = React;

    // --- ICON PLACEHOLDERS (Replacing lucide-react imports for single-file HTML) ---
    const IconWrapper = ({ children, size = 20, className = '', color = 'currentColor' }) => (
        <span className={className} style={{ width: size, height: size, display: 'inline-flex', alignItems: 'center', justifyContent: 'center', color: color }}>{children}</span>
    );
    const Upload = (props) => <IconWrapper {...props}><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></svg></IconWrapper>;
    const FileSpreadsheet = (props) => <IconWrapper {...props}><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M8 12h8"/><path d="M8 16h8"/></svg></IconWrapper>;
    const Info = (props) => <IconWrapper {...props}><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg></IconWrapper>;
    const ChevronDown = (props) => <IconWrapper {...props}><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="6 9 12 15 18 9"/></svg></IconWrapper>;
    const Loader2 = (props) => <IconWrapper {...props} className="animate-spin"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg></IconWrapper>;
    const XIcon = (props) => <IconWrapper {...props}><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg></IconWrapper>;

    const ReconciliationApp = () => {
        // State for step management
        const [step, setStep] = useState(1);
        // State for file data (updated to include column selections)
        const [fileDataA, setFileDataA] = useState({ name: null, headers: [], data: [], idCol: null, amountCol: null });
        const [fileDataB, setFileDataB] = useState({ name: null, headers: [], data: [], idCol: null, amountCol: null });
        // State for reconciliation results
        const [results, setResults] = useState(null);
        // State for loading
        const [isLoading, setIsLoading] = useState(false);
        // State for error messages
        const [error, setError] = useState(null);

        // Utility to format number as currency
        const formatCurrency = (value) => {
            if (typeof value !== 'number') return 'N/A';
            return value.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        };

        // Reads the uploaded Excel file and extracts headers and data
        const processFile = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const sheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[sheetName];

                        // Convert sheet to JSON array
                        let json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                        
                        // Basic check for data existence
                        if (json.length === 0) {
                            reject(new Error("File is empty or could not be parsed."));
                            return;
                        }

                        // Assuming first row is headers
                        const headers = json[0] || [];
                        const contentData = json.slice(1);
                        
                        // Map array data to object structure for easier access
                        const finalData = contentData.map((row, index) => {
                            const rowObj = {};
                            headers.forEach((header, i) => {
                                // Clean up header names: trim whitespace and ensure it's a string
                                const cleanHeader = String(header).trim(); 
                                // Store original value, it will be cleaned later during reconciliation if needed
                                rowObj[cleanHeader] = row[i];
                            });
                            // Add metadata for traceability
                            rowObj['__Original_Row_Index'] = index + 2; // +2 for 1-based index + header row
                            return rowObj;
                        }).filter(row => Object.keys(row).length > 1); // Filter out potentially empty rows

                        if (finalData.length === 0) {
                            reject(new Error("File contains headers but no data rows."));
                            return;
                        }

                        resolve({
                            name: file.name,
                            headers: headers.map(h => String(h).trim()).filter(h => h.length > 0), // Cleaned headers
                            data: finalData,
                            idCol: headers[0] ? String(headers[0]).trim() : null, // Default to first column
                            amountCol: headers[1] ? String(headers[1]).trim() : null, // Default to second column
                        });
                    } catch (err) {
                        reject(new Error(`Failed to process file: ${err.message}`));
                    }
                };
                reader.onerror = (err) => reject(new Error(`File reading error: ${err.message}`));
                reader.readAsArrayBuffer(file);
            });
        };

        // Handles file upload and updates state
        const handleFileChange = (event, fileKey) => {
            setError(null);
            const file = event.target.files[0];
            if (!file) return;

            const updateFunction = fileKey === 'A' ? setFileDataA : setFileDataB;
            
            setIsLoading(true);
            processFile(file)
                .then(data => {
                    updateFunction(data);
                })
                .catch(err => {
                    setError(err.message);
                    updateFunction({ name: null, headers: [], data: [], idCol: null, amountCol: null });
                })
                .finally(() => {
                    setIsLoading(false);
                });
        };

        // Core reconciliation logic
        const performReconciliation = useCallback(() => {
            if (!fileDataA.data.length || !fileDataB.data.length || !fileDataA.idCol || !fileDataB.idCol || !fileDataA.amountCol || !fileDataB.amountCol) {
                setError("Please upload both files and select the Unique ID and Amount columns for reconciliation.");
                return;
            }

            setIsLoading(true);
            setError(null);

            // Column names selected by the user
            const { idCol: idColA, amountCol: amountColA, data: dataA } = fileDataA;
            const { idCol: idColB, amountCol: amountColB, data: dataB } = fileDataB;

            // --- 1. Identify Duplicates and Create Consolidated Maps ---
            const mapA = new Map(); // Key: ID (string), Value: Array of records from A
            const mapB = new Map(); // Key: ID (string), Value: Array of records from B
            
            // To track unique IDs for summary
            const uniqueIdsA = new Set();
            const uniqueIdsB = new Set();
            const duplicateIdsA = new Set();
            const duplicateIdsB = new Set();
            let totalAmountA = 0;
            let totalAmountB = 0;

            const populateMapAndMetrics = (data, map, idCol, amountCol, uniqueIds, duplicateIds, totalAmountRef) => {
                const idCounts = new Map();

                data.forEach(record => {
                    // Unique ID is explicitly converted to string for matching
                    const id = String(record[idCol]).trim(); 
                    if (!id) return; // Skip records with empty IDs
                    
                    // --- Count and Amount Metrics ---
                    // Try to parse amount, default to 0 if NaN
                    const amount = parseFloat(record[amountCol]) || 0;
                    totalAmountRef.current += amount;

                    if (!uniqueIds.has(id)) {
                        uniqueIds.add(id);
                    } else {
                        duplicateIds.add(id);
                    }
                    // --- Mapping for Reconciliation ---
                    if (!map.has(id)) {
                        map.set(id, []);
                    }
                    map.get(id).push({
                        ...record,
                        __Composite_ID: id,
                        __Source_File: record.__Source_File || (data === dataA ? fileDataA.name : fileDataB.name),
                        __Amount_Value: amount, // Store parsed amount
                    });
                });
            };

            // Use refs to pass amount totals by reference
            const totalAmountARef = { current: 0 };
            const totalAmountBRef = { current: 0 };
            
            // Process A
            populateMapAndMetrics(dataA, mapA, idColA, amountColA, uniqueIdsA, duplicateIdsA, totalAmountARef);
            totalAmountA = totalAmountARef.current;

            // Process B
            populateMapAndMetrics(dataB, mapB, idColB, amountColB, uniqueIdsB, duplicateIdsB, totalAmountBRef);
            totalAmountB = totalAmountBRef.current;


            // --- 2. Perform Matching ---
            const matchedA = []; // Records from A that match B
            const unmatchedA = []; // Records from A that do not match B
            const matchedB = []; // Records from B that match A
            const unmatchedB = []; // Records from B that do not match A
            
            const matchedIds = new Set();

            // Iterate through File A unique IDs
            for (const id of mapA.keys()) {
                const recordsA = mapA.get(id);
                const recordsB = mapB.get(id);

                if (recordsB) {
                    // Match found
                    matchedIds.add(id);
                    matchedA.push(...recordsA);
                    matchedB.push(...recordsB);
                    // Remove from mapB so it's not processed as unmatched later
                    mapB.delete(id);
                } else {
                    // No match in B
                    unmatchedA.push(...recordsA);
                }
            }

            // Remaining IDs in mapB are unmatched
            for (const id of mapB.keys()) {
                unmatchedB.push(...mapB.get(id));
            }

            // --- 3. Calculate Final Summary Metrics ---
            const calculateMetrics = (matchedData, unmatchedData, uniqueIdsSet, duplicateIdsSet, totalAmount) => {
                // Calculate Matched and Unmatched amounts
                const matchedAmount = matchedData.reduce((sum, rec) => sum + (rec.__Amount_Value || 0), 0);
                const unmatchedAmount = unmatchedData.reduce((sum, rec) => sum + (rec.__Amount_Value || 0), 0);

                return {
                    consolidatedCount: matchedData.length + unmatchedData.length,
                    consolidatedAmount: totalAmount,
                    matchedCount: matchedData.length,
                    matchedAmount: matchedAmount,
                    unmatchedCount: unmatchedData.length,
                    unmatchedAmount: unmatchedAmount,
                    distinctUniqueIds: uniqueIdsSet.size,
                    duplicatedUniqueIds: duplicateIdsSet.size,
                };
            };
            
            const summaryMetricsA = calculateMetrics(matchedA, unmatchedA, uniqueIdsA, duplicateIdsA, totalAmountA);
            const summaryMetricsB = calculateMetrics(matchedB, unmatchedB, uniqueIdsB, duplicateIdsB, totalAmountB);

            // --- 4. Store Results ---
            setResults({
                matchedA,
                unmatchedA,
                matchedB,
                unmatchedB,
                summaryMetricsA,
                summaryMetricsB,
            });

            setStep(3); // Move to results step
            setIsLoading(false);
        }, [fileDataA, fileDataB]);

        // --- EXCEL GENERATION FUNCTION (Updated for single file, multiple sheets) ---
        const generateConsolidatedReport = useCallback(() => {
            if (!results) return;

            const { matchedA, unmatchedA, matchedB, unmatchedB, summaryMetricsA, summaryMetricsB } = results;

            setIsLoading(true);

            // --- 1. Define Sheets Data ---
            
            // Get all unique headers from A and B data
            const allHeaders = [...new Set([
                ...fileDataA.headers, 
                ...fileDataB.headers, 
                '__Composite_ID', 
                '__Source_File', 
                '__Original_Row_Index'
            ])];

            // Utility to create sheet from data and headers
            const createSheet = (data, headers) => {
                // Map the data to include all headers, ensuring column order
                const sheetData = data.map(row => {
                    const newRow = {};
                    headers.forEach(header => {
                        newRow[header] = row[header] !== undefined ? row[header] : ''; // Use empty string for missing data
                    });
                    return newRow;
                });

                // Prepend headers row
                const finalSheetData = [headers, ...sheetData.map(Object.values)];
                return XLSX.utils.aoa_to_sheet(finalSheetData);
            };

            // --- 2. Create Summary Sheet ---
            const createSummarySheet = (metricsA, metricsB) => {
                const summaryHeaders = ["Metric", "File A", "File B"];
                
                const data = [
                    // A and B headers for distinction
                    ["SUMMARY REPORT FOR RECONCILIATION"],
                    [],
                    // Section 1: Consolidated Metrics
                    ["Total Records (Consolidated)"],
                    [ "Count", metricsA.consolidatedCount, metricsB.consolidatedCount ],
                    [ "Total Amount (Consolidated)", formatCurrency(metricsA.consolidatedAmount), formatCurrency(metricsB.consolidatedAmount) ],
                    [],
                    // Section 2: Match Status
                    ["Match Status"],
                    [ "Matched Records Count", metricsA.matchedCount, metricsB.matchedCount ],
                    [ "Matched Amount Total", formatCurrency(metricsA.matchedAmount), formatCurrency(metricsB.matchedAmount) ],
                    [ "Unmatched Records Count", metricsA.unmatchedCount, metricsB.unmatchedCount ],
                    [ "Unmatched Amount Total", formatCurrency(metricsA.unmatchedAmount), formatCurrency(metricsB.unmatchedAmount) ],
                    [],
                    // Section 3: Unique ID Analysis
                    ["Unique ID Analysis"],
                    [ "Distinct Unique IDs", metricsA.distinctUniqueIds, metricsB.distinctUniqueIds ],
                    [ "Duplicated Unique IDs", metricsA.duplicatedUniqueIds, metricsB.duplicatedUniqueIds ],
                ];
                
                // Create the worksheet from the Array-of-Arrays (AoA)
                const ws = XLSX.utils.aoa_to_sheet(data);

                // Apply some basic styling for headers (optional, mostly visual)
                // Set column widths based on expected content
                ws['!cols'] = [{ wch: 40 }, { wch: 25 }, { wch: 25 }];

                // Add headers for the data rows (Row 4, Row 11, Row 14)
                XLSX.utils.sheet_add_aoa(ws, [summaryHeaders], { origin: "B4" });
                XLSX.utils.sheet_add_aoa(ws, [summaryHeaders], { origin: "B11" });
                XLSX.utils.sheet_add_aoa(ws, [summaryHeaders], { origin: "B14" });
                
                return ws;
            };

            // --- 3. Create Workbook ---
            const workbook = XLSX.utils.book_new();

            // Sheet 1: Matched for A
            XLSX.utils.book_append_sheet(workbook, createSheet(matchedA, allHeaders), "Matched for A");

            // Sheet 2: Unmatched for A
            XLSX.utils.book_append_sheet(workbook, createSheet(unmatchedA, allHeaders), "Unmatched for A");

            // Sheet 3: Matched for B
            XLSX.utils.book_append_sheet(workbook, createSheet(matchedB, allHeaders), "Matched for B");

            // Sheet 4: Unmatched for B
            XLSX.utils.book_append_sheet(workbook, createSheet(unmatchedB, allHeaders), "Unmatched for B");

            // Sheet 5: Summary
            XLSX.utils.book_append_sheet(workbook, createSummarySheet(summaryMetricsA, summaryMetricsB), "Summary");

            // --- 4. Download ---
            XLSX.writeFile(workbook, "Reconciliation_Report.xlsx");
            setIsLoading(false);

        }, [results, fileDataA.headers, fileDataB.headers]);

        // --- UI Components ---
        const FileUploadCard = ({ fileKey, fileData, setFileData }) => {
            const isUploaded = !!fileData.name;
            const updateCol = (colType, value) => {
                setFileData(prev => ({
                    ...prev,
                    [colType === 'id' ? 'idCol' : 'amountCol']: value,
                }));
            };

            return (
                <div className="flex flex-col bg-white p-6 rounded-xl shadow-lg border border-gray-200 relative">
                    <h3 className="text-xl font-bold mb-4 text-gray-800 flex items-center">
                        <FileSpreadsheet size={24} className="mr-2 text-indigo-600" />
                        File {fileKey} ({fileKey === 'A' ? 'Primary' : 'Secondary'})
                    </h3>

                    {/* File Input */}
                    <label className={`block mb-4 text-sm font-medium ${isUploaded ? 'text-green-600' : 'text-gray-700'}`}>
                        {isUploaded ? `File Uploaded: ${fileData.name}` : `Upload File ${fileKey} (.xlsx or .csv)`}
                        <input
                            type="file"
                            accept=".xlsx,.xls,.csv"
                            onChange={(e) => handleFileChange(e, fileKey)}
                            className="hidden"
                            id={`file-upload-${fileKey}`}
                        />
                        <div className={`mt-2 p-3 text-center border-2 border-dashed rounded-lg cursor-pointer transition duration-150 ease-in-out ${isUploaded ? 'border-green-300 bg-green-50 hover:bg-green-100' : 'border-gray-300 bg-gray-50 hover:bg-gray-100'}`}>
                            <Upload size={20} className={`mx-auto mb-1 ${isUploaded ? 'text-green-500' : 'text-gray-400'}`} />
                            <span className="text-sm font-semibold">{isUploaded ? 'Change File' : 'Browse or Drag File'}</span>
                        </div>
                    </label>

                    {/* Column Selectors */}
                    {isUploaded && (
                        <div className="space-y-4 pt-2 border-t border-gray-100">
                            {/* Unique ID Column Selection */}
                            <label className="block">
                                <span className="text-sm font-semibold text-gray-700 block mb-1">
                                    <span className="text-red-500">*</span> Unique ID Column (Matching Key)
                                </span>
                                <div className="relative">
                                    <select
                                        value={fileData.idCol || ''}
                                        onChange={(e) => updateCol('id', e.target.value)}
                                        className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm appearance-none cursor-pointer transition duration-150 ease-in-out"
                                        required
                                    >
                                        <option value="" disabled>Select Unique ID Column</option>
                                        {fileData.headers.map(header => (
                                            <option key={header} value={header}>{header}</option>
                                        ))}
                                    </select>
                                    <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700">
                                        <ChevronDown size={16} />
                                    </div>
                                </div>
                            </label>

                            {/* Amount Column Selection */}
                            <label className="block">
                                <span className="text-sm font-semibold text-gray-700 block mb-1">
                                    <span className="text-red-500">*</span> Amount Column (for Summation)
                                </span>
                                <div className="relative">
                                    <select
                                        value={fileData.amountCol || ''}
                                        onChange={(e) => updateCol('amount', e.target.value)}
                                        className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm appearance-none cursor-pointer transition duration-150 ease-in-out"
                                        required
                                    >
                                        <option value="" disabled>Select Amount Column</option>
                                        {fileData.headers.map(header => (
                                            <option key={header} value={header}>{header}</option>
                                        ))}
                                    </select>
                                    <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700">
                                        <ChevronDown size={16} />
                                    </div>
                                </div>
                            </label>
                        </div>
                    )}
                </div>
            );
        };

        const SummaryTable = ({ metrics, category }) => {
            const dataRows = [
                { label: "Consolidated Records Count", value: formatCurrency(metrics.consolidatedCount) },
                { label: "Consolidated Amount Total", value: formatCurrency(metrics.consolidatedAmount) },
                { label: "Matched Records Count", value: formatCurrency(metrics.matchedCount) },
                { label: "Matched Amount Total", value: formatCurrency(metrics.matchedAmount) },
                { label: "Unmatched Records Count", value: formatCurrency(metrics.unmatchedCount) },
                { label: "Unmatched Amount Total", value: formatCurrency(metrics.unmatchedAmount) },
                { label: "Distinct Unique IDs", value: formatCurrency(metrics.distinctUniqueIds), className: 'border-t border-gray-200 pt-2' },
                { label: "Duplicated Unique IDs", value: formatCurrency(metrics.duplicatedUniqueIds) },
            ];

            return (
                <div className="bg-white p-4 rounded-lg shadow-sm border border-gray-100">
                    <h4 className="text-lg font-bold mb-3 text-indigo-700 border-b pb-2 border-indigo-100">{category} Summary Metrics</h4>
                    <dl className="space-y-2">
                        {dataRows.map((item, index) => (
                            <div key={index} className={`flex justify-between text-sm ${item.className || ''} ${item.label.includes('Total') ? 'font-semibold text-gray-800' : 'text-gray-600'}`}>
                                <dt>{item.label}</dt>
                                <dd className="text-right">{item.value}</dd>
                            </div>
                        ))}
                    </dl>
                </div>
            );
        };


        // --- Main App Render ---
        return (
            <div className="p-4 sm:p-8 max-w-6xl mx-auto relative">
                <header className="text-center mb-8">
                    <h1 className="text-4xl font-extrabold text-gray-900 tracking-tight">
                        Million Dataset Reconciliation Tool
                    </h1>
                    <p className="mt-2 text-lg text-gray-500">
                        Match large datasets (A vs B) using a custom Unique ID and generate a single, consolidated report.
                    </p>
                </header>

                <div className="bg-white p-6 sm:p-8 rounded-2xl shadow-2xl relative">
                    {isLoading && (
                        <div className="loading-overlay">
                            <div className="flex flex-col items-center">
                                <Loader2 size={48} className="text-indigo-500" />
                                <p className="mt-4 text-lg font-semibold text-indigo-700">Processing Data...</p>
                                <p className="text-sm text-gray-500">This may take a moment for large datasets.</p>
                            </div>
                        </div>
                    )}

                    {error && (
                        <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-lg mb-6 flex items-center" role="alert">
                            <Info size={20} className="mr-3 flex-shrink-0" />
                            <div>
                                <p className="font-bold">An Error Occurred</p>
                                <p className="text-sm">{error}</p>
                            </div>
                            <button onClick={() => setError(null)} className="ml-auto p-1 text-red-500 hover:text-red-700"><XIcon size={20} /></button>
                        </div>
                    )}

                    {/* Step 1: File Upload and Column Selection */}
                    {step === 1 && (
                        <div>
                            <h2 className="text-2xl font-semibold text-gray-800 mb-6">
                                1. Upload Files & Select Columns
                            </h2>
                            <div className="grid md:grid-cols-2 gap-8">
                                <FileUploadCard fileKey="A" fileData={fileDataA} setFileData={setFileDataA} />
                                <FileUploadCard fileKey="B" fileData={fileDataB} setFileData={setFileDataB} />
                            </div>

                            <div className="mt-8 pt-6 border-t border-gray-200 flex justify-center">
                                <button
                                    onClick={performReconciliation}
                                    disabled={!fileDataA.name || !fileDataB.name || !fileDataA.idCol || !fileDataB.idCol || !fileDataA.amountCol || !fileDataB.amountCol || isLoading}
                                    className="px-8 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                                >
                                    {isLoading ? 'Processing...' : '2. Perform Reconciliation'}
                                </button>
                            </div>
                            <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mt-6">
                                <p className="text-sm text-blue-800 flex items-start">
                                    <Info size={18} className="mr-2 mt-0.5 flex-shrink-0 text-blue-600" />
                                    <span>
                                        **Important:** Ensure your selected Unique ID column is consistent across both files and **will be treated as text (string)** during matching to prevent data truncation or misinterpretation of large numerical IDs.
                                    </span>
                                </p>
                            </div>
                        </div>
                    )}

                    {/* Step 2: Results & Download */}
                    {step === 3 && results && (
                        <div className="relative">
                            <h2 className="text-2xl font-semibold text-gray-800 mb-6">
                                3. Reconciliation Complete
                            </h2>

                            {/* Structured Summary Tables */}
                            <div className="bg-gray-50 rounded-xl p-6 mb-8 border border-gray-200">
                                <h3 className="font-bold text-2xl mb-4 text-gray-800 text-center">Summary Metrics Overview</h3>
                                <div className="grid lg:grid-cols-2 gap-6">
                                    <SummaryTable metrics={results.summaryMetricsA} category={`File A: ${fileDataA.name}`} />
                                    <SummaryTable metrics={results.summaryMetricsB} category={`File B: ${fileDataB.name}`} />
                                </div>
                            </div>
                            
                            {/* Download Action */}
                            <div className="text-center space-y-4">
                                <button
                                    onClick={generateConsolidatedReport}
                                    disabled={isLoading}
                                    className="px-10 py-4 bg-green-600 text-white text-lg font-bold rounded-lg shadow-xl hover:bg-green-700 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center mx-auto"
                                >
                                    <FileSpreadsheet size={24} className="mr-3" />
                                    {isLoading ? 'Generating File...' : 'Download Consolidated Report (1 File, 5 Sheets)'}
                                </button>
                                
                                <p className="text-sm text-gray-600">
                                    This will generate a single Excel file containing the four detailed data sheets and the combined Summary sheet.
                                </p>
                            </div>

                            <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mt-8">
                                <p className="text-sm text-blue-800 flex items-start">
                                    <Info size={18} className="mr-2 mt-0.5 flex-shrink-0 text-blue-600" />
                                    <span>
                                        **Traceability Note:** All generated data sheets include the **`__Composite_ID`** (the key used for matching), **`__Source_File`**, and **`__Original_Row_Index`** (the exact row number in the source file) columns for traceability back to the origin.
                                    </span>
                                </p>
                            </div>

                            <div className="text-center pt-8">
                                <button 
                                    onClick={() => { setStep(1); setResults(null); setFileDataA({ name: null, headers: [], data: [], idCol: null, amountCol: null }); setFileDataB({ name: null, headers: [], data: [], idCol: null, amountCol: null }); }} 
                                    className="px-6 py-3 border border-gray-300 text-gray-700 font-semibold rounded-lg hover:bg-gray-100 transition duration-200"
                                >
                                    Start New Reconciliation
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            </div>
        );
    };

    // Render the React application
    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    root.render(<ReconciliationApp />);

    </script>
</body>
</html>
