<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Transaction Reconciliation Tool</title>
    <!-- Load React and ReactDOM from CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Load Babel for JSX transpilation in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load SheetJS/XLSX for Excel file handling -->
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
</head>
<body class="bg-gray-50 min-h-screen font-sans">
    <div id="root"></div>

    <script type="text/babel">
    // Destructure hooks from the global React object for easy access
    const { useState, useEffect, useCallback, useMemo } = React;
    
    // --- UTILITY FUNCTIONS ---
    
    // Icon Placeholders
    const IconWrapper = ({ children, size = 20, className = '', color = 'currentColor' }) => (
        <span className={className} style={{ width: size, height: size, display: 'inline-flex', alignItems: 'center', justifyContent: 'center', color: color }}>{children}</span>
    );
    const Upload = (props) => <IconWrapper {...props}><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" class="lucide lucide-upload"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></svg></IconWrapper>;
    const Info = (props) => <IconWrapper {...props}><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" class="lucide lucide-info"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg></IconWrapper>;
    const Check = (props) => <IconWrapper {...props}><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" class="lucide lucide-check"><path d="M20 6 9 17l-5-5"/></svg></IconWrapper>;
    const FileSpreadsheet = (props) => <IconWrapper {...props}><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" class="lucide lucide-file-spreadsheet"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M8 12h8"/><path d="M8 16h8"/><path d="M8 20h8"/></svg></IconWrapper>;


    // Format number to currency
    const formatAmount = (num) => {
        if (typeof num !== 'number' || isNaN(num)) return '0.00';
        return num.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    };

    // Robust amount parser
    const parseAmount = (value) => {
        if (typeof value === 'number') return value;
        if (typeof value === 'string') {
            const cleaned = value.replace(/[^0-9.-]/g, '');
            const parsed = parseFloat(cleaned);
            return isNaN(parsed) ? 0 : parsed;
        }
        return 0;
    };

    // --- RECONCILIATION LOGIC ---
    
    /**
     * Executes the core reconciliation logic using selected columns.
     */
    const runReconciliation = (files, idColumnA, amountColumnA, idColumnB, amountColumnB) => {
        if (!files.A.data || !files.B.data) return null;

        // 1. Process and Normalize Data
        const processData = (fileData, fileName, idCol, amountCol) => {
            const processed = [];
            const idCounts = new Map();

            fileData.forEach((row, index) => {
                const uniqueId = String(row[idCol] || '').trim();
                const amount = parseAmount(row[amountCol]);

                if (!uniqueId) return; // Skip rows with no Unique ID

                // Create the composite key for matching
                const compositeId = `${uniqueId}_${amount.toFixed(2)}`;

                // Track ID appearances for duplication check
                const currentCount = idCounts.get(uniqueId) || 0;
                idCounts.set(uniqueId, currentCount + 1);

                processed.push({
                    ...row,
                    'Composite_ID': compositeId,
                    'Unique_ID': uniqueId,
                    'Amount': amount,
                    '__Source_File': fileName,
                    '__Original_Row_Index': index + 2, // +2 because index is 0-based and includes header row
                });
            });

            return { processed, idCounts };
        };

        const { processed: dataA, idCounts: idCountsA } = processData(files.A.data, files.A.name, idColumnA, amountColumnA);
        const { processed: dataB, idCounts: idCountsB } = processData(files.B.data, files.B.name, idColumnB, amountColumnB);

        // 2. Identify Matched, Unmatched, and Duplicated
        const matchedKeys = new Set();
        const unmatchedA = [];
        const unmatchedB = [];
        const matched = [];
        const allKeys = new Set();
        
        // Use a Map to quickly check for existence in the other dataset
        const compositeMapB = new Map();
        dataB.forEach(row => {
            if (!compositeMapB.has(row.Composite_ID)) {
                compositeMapB.set(row.Composite_ID, []);
            }
            compositeMapB.get(row.Composite_ID).push(row);
            allKeys.add(row.Composite_ID);
        });

        // Pass 1: Match A to B
        const compositeMapA = new Map();
        dataA.forEach(row => {
            const compositeKey = row.Composite_ID;
            
            if (compositeMapB.has(compositeKey) && compositeMapB.get(compositeKey).length > 0) {
                // Found a match
                const matchB = compositeMapB.get(compositeKey).shift(); // Take one match and remove it
                matched.push({ ...row, ...matchB });
                matchedKeys.add(compositeKey);
            } else {
                unmatchedA.push(row);
            }

            // Track for duplication later (even if matched/unmatched)
            if (!compositeMapA.has(row.Unique_ID)) {
                compositeMapA.set(row.Unique_ID, []);
            }
            compositeMapA.get(row.Unique_ID).push(row);
        });

        // Pass 2: Remaining in B are Unmatched
        compositeMapB.forEach(rows => {
            unmatchedB.push(...rows);
        });
        
        // 3. Identify Duplicates (Unique ID appears more than once in its source file)
        const getDuplicates = (data, idCounts) => data.filter(row => idCounts.get(row.Unique_ID) > 1);

        const duplicatesA = getDuplicates(dataA, idCountsA);
        const duplicatesB = getDuplicates(dataB, idCountsB);

        // 4. Calculate Summary Metrics (Required for On-Screen Display and Downloads)
        const calculateMetrics = (data, duplicates) => {
            const distinctIds = new Set(data.map(d => d.Unique_ID)).size;
            const totalAmount = data.reduce((sum, row) => sum + row.Amount, 0);

            const matchedData = data.filter(row => matchedKeys.has(row.Composite_ID));
            const unmatchedData = data.filter(row => !matchedKeys.has(row.Composite_ID));
            
            return {
                totalCount: data.length,
                totalAmount: totalAmount,
                distinctIdCount: distinctIds,
                
                matchedCount: matchedData.length,
                matchedAmount: matchedData.reduce((sum, row) => sum + row.Amount, 0),

                unmatchedCount: unmatchedData.length,
                unmatchedAmount: unmatchedData.reduce((sum, row) => sum + row.Amount, 0),

                duplicateCount: duplicates.length,
                duplicateAmount: duplicates.reduce((sum, row) => sum + row.Amount, 0),
            };
        };

        const summaryMetricsA = calculateMetrics(dataA, duplicatesA);
        const summaryMetricsB = calculateMetrics(dataB, duplicatesB);
        
        // 5. Final Results Structure
        return {
            dataA, dataB,
            matched, unmatchedA, unmatchedB,
            duplicatesA, duplicatesB,
            summaryMetricsA, summaryMetricsB,
        };
    };

    // --- DOWNLOAD LOGIC ---

    const generateDownloadFiles = (results, idColumnA, amountColumnA, idColumnB, amountColumnB) => {
        const wb = XLSX.utils.book_new();
        const { summaryMetricsA, summaryMetricsB } = results;

        // Helper to convert array of objects to worksheet
        const aoaToSheet = (data, sheetName, prefix) => {
            if (data.length > 0) {
                const ws = XLSX.utils.json_to_sheet(data);
                XLSX.utils.book_append_sheet(wb, ws, prefix + sheetName);
            }
        };

        // --- 1-3. Category A Analysis Sheets ---
        aoaToSheet(results.matched.map(r => r.dataA), "A_Matched", "A - ");
        aoaToSheet(results.unmatchedA, "A_Unmatched", "A - ");
        aoaToSheet(results.duplicatesA, "A_Duplicates", "A - ");

        // --- 4-6. Category B Analysis Sheets ---
        aoaToSheet(results.matched.map(r => r.dataB), "B_Matched", "B - ");
        aoaToSheet(results.unmatchedB, "B_Unmatched", "B - ");
        aoaToSheet(results.duplicatesB, "B_Duplicates", "B - ");

        // --- 7. Full Matched Report ---
        aoaToSheet(results.matched, "Full Match Report");

        // --- 8. Combined Unmatched Report ---
        const combinedUnmatched = [
            ...results.unmatchedA.map(r => ({ ...r, '__Match_Status': 'Unmatched A' })),
            ...results.unmatchedB.map(r => ({ ...r, '__Match_Status': 'Unmatched B' })),
        ];
        aoaToSheet(combinedUnmatched, "Combined Unmatched");


        // --- 9. Summary A & B Side-by-Side (The complex sheet) ---
        const sA = summaryMetricsA;
        const sB = summaryMetricsB;

        const summaryData = [
            // Header Row
            ['Metric', 'Category A Unique ID Count', 'Category A Amount', 'Category B Unique ID Count', 'Category B Amount'],

            // 1. Distinct Unique ID count and amount (Matched + Unmatched)
            ['Distinct Unique ID (Count/Amount)', sA.distinctIdCount, formatAmount(sA.totalAmount), sB.distinctIdCount, formatAmount(sB.totalAmount)],

            // 2. Total Duplicated unique ID count and amount
            ['Total Duplicated Unique ID (Count/Amount)', sA.duplicateCount, formatAmount(sA.duplicateAmount), sB.duplicateCount, formatAmount(sB.duplicateAmount)],

            // 3. Total of the 2 (Sum of Distinct and Duplicated)
            ['Total (Distinct + Duplicated)', 
                sA.distinctIdCount + sA.duplicateCount, formatAmount(sA.totalAmount + sA.duplicateAmount), 
                sB.distinctIdCount + sB.duplicateCount, formatAmount(sB.totalAmount + sB.duplicateAmount)
            ],

            // 4. Total matched and unmatched count and amount (Total Data Count/Amount)
            ['Total Matched & Unmatched (Total Records)', 
                sA.totalCount, formatAmount(sA.totalAmount), 
                sB.totalCount, formatAmount(sB.totalAmount)
            ],
            
            // 5. Deduct the 2 totals (Row 4 minus Row 3)
            ['Deduct the 2 Totals (Row 4 - Row 3)', 
                (sA.totalCount) - (sA.distinctIdCount + sA.duplicateCount), 
                formatAmount(sA.totalAmount - (sA.totalAmount + sA.duplicateAmount)), // Should result in -DuplicateAmount
                (sB.totalCount) - (sB.distinctIdCount + sB.duplicateCount),
                formatAmount(sB.totalAmount - (sB.totalAmount + sB.duplicateAmount)) // Should result in -DuplicateAmount
            ],

            // Add the standard Matched/Unmatched breakdown for context
            ['', '', '', '', ''],
            ['--- Breakdown ---', '', '', '', ''],
            ['Matched Records', sA.matchedCount, formatAmount(sA.matchedAmount), sB.matchedCount, formatAmount(sB.matchedAmount)],
            ['Unmatched Records', sA.unmatchedCount, formatAmount(sA.unmatchedAmount), sB.unmatchedCount, formatAmount(sB.unmatchedAmount)],
            ['Total Records Check', sA.totalCount, formatAmount(sA.totalAmount), sB.totalCount, formatAmount(sB.totalAmount)],

        ];

        const summaryWs = XLSX.utils.aoa_to_sheet(summaryData);
        XLSX.utils.book_append_sheet(wb, summaryWs, "A & B Reconciliation Summary");

        // Write and download the workbook
        XLSX.writeFile(wb, "Reconciliation_Report_" + new Date().toISOString().slice(0, 10) + ".xlsx");
    };

    // --- REACT COMPONENTS ---

    const SelectFile = ({ name, category, file, onFileChange }) => {
        return (
            <div className="flex flex-col space-y-2 p-6 bg-white border border-gray-200 rounded-xl shadow-lg hover:shadow-xl transition duration-300">
                <h3 className="text-xl font-semibold text-gray-800 mb-2">{category}</h3>
                <label className="block text-sm font-medium text-gray-700">
                    Source File ({name})
                </label>
                <div className="mt-1 flex justify-center px-6 pt-5 pb-6 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer hover:border-blue-400 transition duration-150">
                    <input
                        type="file"
                        id={`file-upload-${name}`}
                        className="hidden"
                        onChange={(e) => onFileChange(e, name)}
                        accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel"
                    />
                    <label htmlFor={`file-upload-${name}`} className="text-center cursor-pointer">
                        {file ? (
                            <div className="text-green-600 font-medium">
                                <FileSpreadsheet className="mx-auto" size={28} color="green" />
                                {file.name} loaded.
                            </div>
                        ) : (
                            <div className="space-y-1">
                                <Upload className="mx-auto" size={28} color="#4f46e5" />
                                <p className="text-sm text-gray-600">
                                    <span className="font-medium text-blue-600 hover:text-blue-500">
                                        Click to upload
                                    </span>
                                    {' or drag and drop'}
                                </p>
                                <p className="text-xs text-gray-500">
                                    XLSX, XLS, CSV (up to 10MB)
                                </p>
                            </div>
                        )}
                    </label>
                </div>
            </div>
        );
    };

    const ColumnSelector = ({ category, headers, selectedId, selectedAmount, onSelectId, onSelectAmount }) => (
        <div className="p-6 bg-white border border-gray-200 rounded-xl shadow-lg">
            <h3 className="text-xl font-semibold text-gray-800 mb-4">{category} Column Mapping</h3>
            
            <div className="space-y-4">
                {/* Unique ID Selector */}
                <div>
                    <label htmlFor={`${category}-id`} className="block text-sm font-medium text-gray-700 mb-1">
                        Select Unique ID Column (Key)
                    </label>
                    <select
                        id={`${category}-id`}
                        value={selectedId}
                        onChange={(e) => onSelectId(e.target.value)}
                        className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md shadow-sm"
                    >
                        <option value="">-- Select ID Column --</option>
                        {headers.map(h => (
                            <option key={h} value={h}>{h}</option>
                        ))}
                    </select>
                </div>

                {/* Amount Selector */}
                <div>
                    <label htmlFor={`${category}-amount`} className="block text-sm font-medium text-gray-700 mb-1">
                        Select Amount Column (Value)
                    </label>
                    <select
                        id={`${category}-amount`}
                        value={selectedAmount}
                        onChange={(e) => onSelectAmount(e.target.value)}
                        className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md shadow-sm"
                    >
                        <option value="">-- Select Amount Column --</option>
                        {headers.map(h => (
                            <option key={h} value={h}>{h}</option>
                        ))}
                    </select>
                </div>
            </div>
        </div>
    );

    const SummaryTable = ({ metrics, category }) => {
        const data = [
            { label: 'Matched', count: metrics.matchedCount, amount: metrics.matchedAmount, color: 'text-green-600' },
            { label: 'Unmatched', count: metrics.unmatchedCount, amount: metrics.unmatchedAmount, color: 'text-red-600' },
            { label: 'Total', count: metrics.totalCount, amount: metrics.totalAmount, color: 'font-bold text-gray-900' },
        ];
        
        return (
            <div className="bg-white border border-gray-300 rounded-xl shadow-md overflow-hidden">
                <h3 className="text-center p-3 text-lg font-bold text-blue-700 bg-blue-50 border-b border-blue-200">{category} Summary</h3>
                <table className="min-w-full divide-y divide-gray-200">
                    <thead className="bg-gray-50">
                        <tr>
                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                            <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Count</th>
                            <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Amount</th>
                        </tr>
                    </thead>
                    <tbody className="bg-white divide-y divide-gray-200">
                        {data.map(({ label, count, amount, color }) => (
                            <tr key={label} className={label === 'Total' ? 'bg-gray-100 font-semibold' : ''}>
                                <td className={`px-6 py-3 whitespace-nowrap text-sm ${color}`}>{label}</td>
                                <td className={`px-6 py-3 whitespace-nowrap text-sm text-right ${color}`}>{count.toLocaleString()}</td>
                                <td className={`px-6 py-3 whitespace-nowrap text-sm text-right ${color}`}>${formatAmount(amount)}</td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        );
    };


    // --- MAIN APPLICATION COMPONENT ---

    const ReconciliationApp = () => {
        const [step, setStep] = useState(1); // 1: Upload, 2: Map Columns, 3: Results
        const [files, setFiles] = useState({
            A: { name: 'Category_A.xlsx', data: null },
            B: { name: 'Category_B.xlsx', data: null },
        });
        const [columnHeaders, setColumnHeaders] = useState([]);
        const [idColumnA, setIdColumnA] = useState('');
        const [amountColumnA, setAmountColumnA] = useState('');
        const [idColumnB, setIdColumnB] = useState('');
        const [amountColumnB, setAmountColumnB] = useState('');
        const [results, setResults] = useState(null);
        const [loading, setLoading] = useState(false);
        const [error, setError] = useState(null);

        // Effect to pre-select columns if headers are available and columns are found
        useEffect(() => {
            if (step === 2 && columnHeaders.length > 0) {
                const normalizedHeaders = columnHeaders.map(h => h.toLowerCase().replace(/[^a-z0-9]/g, ''));
                
                const findBestMatch = (keywords) => {
                    for (const keyword of keywords) {
                        const match = columnHeaders.find(h => h.toLowerCase().includes(keyword));
                        if (match) return match;
                    }
                    return '';
                };

                // Auto-select ID/Ref/Key
                const defaultId = findBestMatch(['id', 'ref', 'key', 'unique']);
                setIdColumnA(defaultId);
                setIdColumnB(defaultId);
                
                // Auto-select Amount/Value/Debit/Credit
                const defaultAmount = findBestMatch(['amount', 'value', 'debit', 'credit', 'total']);
                setAmountColumnA(defaultAmount);
                setAmountColumnB(defaultAmount);
            }
        }, [step, columnHeaders]);


        // File change handler
        const handleFileChange = (event, fileKey) => {
            setError(null);
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    
                    // Convert sheet to JSON array of objects
                    const json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                    const headers = json[0]; // First row is headers
                    const dataRows = json.slice(1); // Data starts from the second row

                    if (!headers || headers.length === 0 || dataRows.length === 0) {
                        throw new Error("File is empty or could not parse headers/data.");
                    }
                    
                    // Map data rows to objects using headers
                    const parsedData = dataRows.map(row => {
                        const obj = {};
                        headers.forEach((header, i) => {
                            // Trim header name and use the original row value
                            obj[String(header).trim()] = row[i];
                        });
                        return obj;
                    });
                    
                    setFiles(prev => {
                        const newFiles = { ...prev, [fileKey]: { name: file.name, data: parsedData } };

                        // If both files are loaded, extract combined unique headers and proceed to step 2
                        if (newFiles.A.data && newFiles.B.data) {
                            const uniqueHeaders = Array.from(new Set([
                                ...Object.keys(newFiles.A.data[0] || {}),
                                ...Object.keys(newFiles.B.data[0] || {}),
                            ]));
                            setColumnHeaders(uniqueHeaders.filter(h => h && h.trim() !== ''));
                            setStep(2);
                        }
                        return newFiles;
                    });

                } catch (err) {
                    console.error("File processing error:", err);
                    setError(`Error reading file: ${err.message}. Please ensure it is a valid CSV or Excel file.`);
                    setFiles(prev => ({ ...prev, [fileKey]: { name: prev[fileKey].name, data: null } }));
                }
            };
            reader.readAsArrayBuffer(file);
        };

        // Reconciliation function caller
        const handleReconcile = () => {
            if (!idColumnA || !amountColumnA || !idColumnB || !amountColumnB) {
                setError("Please select both Unique ID and Amount columns for both categories before proceeding.");
                return;
            }
            if (!files.A.data || !files.B.data) {
                setError("Please upload both files.");
                return;
            }

            setError(null);
            setLoading(true);
            setTimeout(() => { // Use setTimeout to allow loading state to render
                try {
                    const reconciliationResults = runReconciliation(files, idColumnA, amountColumnA, idColumnB, amountColumnB);
                    setResults(reconciliationResults);
                    setStep(3);
                } catch (err) {
                    console.error("Reconciliation failed:", err);
                    setError("An error occurred during reconciliation. Check console for details.");
                } finally {
                    setLoading(false);
                }
            }, 50);
        };

        // Reset function
        const handleReset = () => {
            setStep(1);
            setFiles({ A: { name: 'Category_A.xlsx', data: null }, B: { name: 'Category_B.xlsx', data: null } });
            setColumnHeaders([]);
            setResults(null);
            setError(null);
            setIdColumnA('');
            setAmountColumnA('');
            setIdColumnB('');
            setAmountColumnB('');
        };
        
        return (
            <div className="max-w-7xl mx-auto p-4 md:p-8">
                <header className="text-center mb-8">
                    <h1 className="text-4xl font-extrabold text-gray-900 tracking-tight">
                        Transaction Reconciliation Tool
                    </h1>
                    <p className="mt-2 text-lg text-gray-600">
                        Match transactions between two datasets using custom ID and Amount columns.
                    </p>
                </header>

                <div className="bg-white p-6 md:p-10 rounded-3xl shadow-2xl border border-gray-100">
                    
                    {/* Error Message Display */}
                    {error && (
                        <div className="mb-6 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg flex items-start">
                            <Info className="flex-shrink-0 mt-0.5" color="red" />
                            <span className="ml-3 font-medium">{error}</span>
                        </div>
                    )}
                    
                    {/* STEP 1: Upload Files */}
                    {step === 1 && (
                        <div>
                            <h2 className="text-2xl font-bold text-gray-800 mb-6">
                                Step 1: Upload Source Files
                            </h2>
                            <div className="grid md:grid-cols-2 gap-6">
                                <SelectFile 
                                    name="A" 
                                    category="Category A" 
                                    file={files.A.data ? files.A : null}
                                    onFileChange={handleFileChange}
                                />
                                <SelectFile 
                                    name="B" 
                                    category="Category B" 
                                    file={files.B.data ? files.B : null}
                                    onFileChange={handleFileChange}
                                />
                            </div>
                            <div className="mt-8 p-4 bg-blue-50 border border-blue-200 rounded-lg text-sm text-blue-800 flex items-start">
                                <Info className="flex-shrink-0 mt-0.5" color="#2563eb" />
                                <span className="ml-3">
                                    Upload your two comparison files above. Once both are successfully parsed, you will automatically proceed to Step 2 for column mapping.
                                </span>
                            </div>
                        </div>
                    )}

                    {/* STEP 2: Column Mapping */}
                    {step === 2 && (
                        <div>
                            <h2 className="text-2xl font-bold text-gray-800 mb-6">
                                Step 2: Map Reconciliation Columns
                            </h2>
                            <p className="text-gray-600 mb-6">
                                Please select the correct **Unique ID** (for the matching key) and **Amount** (for the matching value) columns from the headers detected in your uploaded files.
                            </p>
                            <div className="grid md:grid-cols-2 gap-6">
                                <ColumnSelector 
                                    category="Category A"
                                    headers={columnHeaders}
                                    selectedId={idColumnA}
                                    selectedAmount={amountColumnA}
                                    onSelectId={setIdColumnA}
                                    onSelectAmount={setAmountColumnA}
                                />
                                <ColumnSelector 
                                    category="Category B"
                                    headers={columnHeaders}
                                    selectedId={idColumnB}
                                    selectedAmount={amountColumnB}
                                    onSelectId={setIdColumnB}
                                    onSelectAmount={setAmountColumnB}
                                />
                            </div>
                            <div className="flex justify-end mt-8 space-x-4">
                                <button 
                                    onClick={() => setStep(1)} 
                                    className="px-6 py-3 border border-gray-300 text-gray-700 font-semibold rounded-lg hover:bg-gray-100 transition duration-200"
                                >
                                    &larr; Change Files
                                </button>
                                <button 
                                    onClick={handleReconcile}
                                    disabled={!idColumnA || !amountColumnA || !idColumnB || !amountColumnB || loading}
                                    className={`px-8 py-3 rounded-lg text-white font-semibold transition duration-200 ${
                                        (!idColumnA || !amountColumnA || !idColumnB || !amountColumnB || loading) 
                                            ? 'bg-blue-400 cursor-not-allowed' 
                                            : 'bg-blue-600 hover:bg-blue-700 shadow-md'
                                    }`}
                                >
                                    {loading ? (
                                        <span className="flex items-center">
                                            <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                                            Running Reconciliation...
                                        </span>
                                    ) : (
                                        'Run Reconciliation'
                                    )}
                                </button>
                            </div>
                        </div>
                    )}

                    {/* STEP 3: Results and Download */}
                    {step === 3 && results && (
                        <div>
                            <h2 className="text-2xl font-bold text-green-700 mb-6 flex items-center">
                                <Check size={28} className="mr-2" color="#047857" />
                                Step 3: Reconciliation Complete
                            </h2>
                            <p className="text-gray-600 mb-8">
                                The reconciliation process has finished. Below is the simplified summary of matched and unmatched records.
                                Use the button below to download the detailed, multi-sheet report for full analysis.
                            </p>

                            {/* Simplified On-Screen Summary Tables */}
                            <div className="grid md:grid-cols-2 gap-6 mb-8">
                                <SummaryTable 
                                    metrics={results.summaryMetricsA} 
                                    category={`Category A (using ID: ${idColumnA}, Amt: ${amountColumnA})`} 
                                />
                                <SummaryTable 
                                    metrics={results.summaryMetricsB} 
                                    category={`Category B (using ID: ${idColumnB}, Amt: ${amountColumnB})`} 
                                />
                            </div>

                            <div className="flex flex-col md:flex-row justify-between items-center bg-blue-50 border border-blue-200 rounded-xl p-6 shadow-lg">
                                <div className="mb-4 md:mb-0">
                                    <h3 className="text-xl font-bold text-blue-800 flex items-center">
                                        <FileSpreadsheet size={24} className="mr-2" color="#1e40af" />
                                        Download Full Reconciliation Report
                                    </h3>
                                    <p className="text-sm text-blue-700 mt-1">
                                        This file contains all 9 sheets including the detailed matched, unmatched, duplicates, and the complex A & B Summary.
                                    </p>
                                </div>
                                <button 
                                    onClick={() => generateDownloadFiles(results, idColumnA, amountColumnA, idColumnB, amountColumnB)}
                                    className="px-8 py-3 bg-indigo-600 text-white font-semibold rounded-lg hover:bg-indigo-700 shadow-md transition duration-200 flex items-center"
                                >
                                    Download All Reports (.xlsx)
                                </button>
                            </div>

                            <div className="text-center pt-8">
                                <button 
                                    onClick={handleReset} 
                                    className="px-6 py-3 border border-gray-300 text-gray-700 font-semibold rounded-lg hover:bg-gray-100 transition duration-200"
                                >
                                    Start New Reconciliation
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            </div>
        );
    };
    
    // Render the React application
    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    root.render(<ReconciliationApp />);

    </script>
</body>
</html>
