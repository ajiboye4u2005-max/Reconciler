<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Reconciliation Tool (Selective Columns)</title>
    <!-- Load React and ReactDOM from CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Load Babel for JSX transpilation in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load SheetJS/XLSX for Excel file handling -->
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
    <style>
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            border-radius: 0.5rem;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen font-sans">
    <div id="root"></div>

    <script type="text/babel">
    // Destructure hooks from the global React object for easy access (FIX: addresses ReferenceError: useState is not defined)
    const { useState, useEffect, useCallback, useMemo } = React;
    
    // --- ICON PLACEHOLDERS (Replacing lucide-react imports for single-file HTML) ---
    const IconWrapper = ({ children, size = 20, className = '', color = 'currentColor' }) => (
        <span className={className} style={{ width: size, height: size, display: 'inline-flex', alignItems: 'center', justifyContent: 'center', color: color }}>{children}</span>
    );
    const Upload = (props) => <IconWrapper {...props}><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-upload"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></svg></IconWrapper>;
    const FileSpreadsheet = (props) => <IconWrapper {...props}><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-file-spreadsheet"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M8 12h8"/><path d="M8 16h8"/><path d="M8 20h8"/></svg></IconWrapper>;
    const ListChecks = (props) => <IconWrapper {...props}><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-list-checks"><path d="m3 12 2 2 4-4"/><path d="M13 6H3"/><path d="M17 6H3"/><path d="M17 12H3"/><path d="M21 12H11"/><path d="M17 18H3"/><path d="M21 18H11"/></svg></IconWrapper>;
    const Info = (props) => <IconWrapper {...props}><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-info"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg></IconWrapper>;
    const Download = (props) => <IconWrapper {...props}><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-download"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg></IconWrapper>;

    // --- UTILITIES ---

    // Constants for File Data Structure
    const initialState = { name: null, headers: [], data: [], idCol: null, amountCol: null };
    const MANDATORY_TRACEABILITY_COLUMNS = ['__Composite_ID', '__Source_File', '__Original_Row_Index', '__Appearance_Count'];

    // Utility to convert Array Buffer to Workbook
    const processWorkbook = (data) => {
        const workbook = XLSX.read(data, { type: 'array' });
        const sheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[sheetName];
        // Convert sheet to array of objects (JSON format)
        const json = XLSX.utils.sheet_to_json(worksheet);
        const headers = json.length > 0 ? Object.keys(json[0]) : [];
        return { json, headers };
    };

    // Filters data rows to only include the specified columns
    const filterDataByColumns = (data, columns) => {
        return data.map(row => {
            const newRow = {};
            columns.forEach(col => {
                if (row.hasOwnProperty(col)) {
                    // Check if the property exists before copying
                    newRow[col] = row[col];
                }
            });
            return newRow;
        });
    };

    // --- CORE LOGIC ---

    const reconcileData = (fileA, fileB, selectedReportColumns) => {
        const mandatoryColumns = ['__Composite_ID', '__Source_File', '__Original_Row_Index', '__Appearance_Count'];
        const allOutputColumns = [...mandatoryColumns, ...Array.from(selectedReportColumns)];

        const dataA = fileA.data;
        const dataB = fileB.data;

        // 1. Create a consolidated key map for File A
        const mapA = new Map();
        dataA.forEach((row, index) => {
            // Composite key: ID value + Amount value (for double check)
            const key = `${row[fileA.idCol]}_${row[fileA.amountCol]}`;
            if (!mapA.has(key)) {
                mapA.set(key, []);
            }
            mapA.get(key).push({
                ...row,
                '__Source_File': fileA.name,
                '__Original_Row_Index': index + 2, // +2 for 1-based index and header row
                '__Composite_ID': key,
                '__Appearance_Count': 0 // Will be updated later
            });
        });

        // 2. Create a consolidated key map for File B
        const mapB = new Map();
        dataB.forEach((row, index) => {
            const key = `${row[fileB.idCol]}_${row[fileB.amountCol]}`;
            if (!mapB.has(key)) {
                mapB.set(key, []);
            }
            mapB.get(key).push({
                ...row,
                '__Source_File': fileB.name,
                '__Original_Row_Index': index + 2,
                '__Composite_ID': key,
                '__Appearance_Count': 0
            });
        });

        // 3. Find Matches and Uniques
        const matchedKeys = new Set();
        const uniqueKeysA = new Set(mapA.keys());
        const uniqueKeysB = new Set(mapB.keys());

        // Identify keys present in both
        for (const key of mapA.keys()) {
            if (mapB.has(key)) {
                matchedKeys.add(key);
                uniqueKeysA.delete(key);
                uniqueKeysB.delete(key);
            }
        }

        let matched = [];
        let uniqueA = [];
        let uniqueB = [];

        // Process Matched records
        for (const key of matchedKeys) {
            const recordsA = mapA.get(key);
            const recordsB = mapB.get(key);
            const allRecords = [...recordsA, ...recordsB];
            const appearanceCount = allRecords.length;

            // Update Appearance Count and push to matched list
            allRecords.forEach(record => {
                matched.push({ ...record, '__Appearance_Count': appearanceCount });
            });
        }

        // Process Unique A records
        for (const key of uniqueKeysA) {
            const recordsA = mapA.get(key);
            const appearanceCount = recordsA.length;
            recordsA.forEach(record => {
                uniqueA.push({ ...record, '__Appearance_Count': appearanceCount });
            });
        }

        // Process Unique B records
        for (const key of uniqueKeysB) {
            const recordsB = mapB.get(key);
            const appearanceCount = recordsB.length;
            recordsB.forEach(record => {
                uniqueB.push({ ...record, '__Appearance_Count': appearanceCount });
            });
        }

        // --- FILTERING AND FINAL OUTPUT ---
        // Filter the datasets to include only the selected columns + mandatory ones
        const finalMatched = filterDataByColumns(matched, allOutputColumns);
        const finalUniqueA = filterDataByColumns(uniqueA, allOutputColumns);
        const finalUniqueB = filterDataByColumns(uniqueB, allOutputColumns);

        // Calculate Summary Metrics
        const summaryMetricsA = [
            { label: `Total Records in ${fileA.name}`, value: dataA.length },
            { label: `Matched Records from ${fileA.name}`, value: matched.filter(r => r.__Source_File === fileA.name).length },
            { label: `Unique Records in ${fileA.name}`, value: uniqueA.length },
        ];
        const summaryMetricsB = [
            { label: `Total Records in ${fileB.name}`, value: dataB.length },
            { label: `Matched Records from ${fileB.name}`, value: matched.filter(r => r.__Source_File === fileB.name).length },
            { label: `Unique Records in ${fileB.name}`, value: uniqueB.length },
        ];

        return {
            matched: finalMatched,
            uniqueA: finalUniqueA,
            uniqueB: finalUniqueB,
            summaryMetricsA,
            summaryMetricsB,
        };
    };

    // Utility to download data as an Excel file
    const downloadExcel = (data, filename) => {
        if (!data || data.length === 0) {
            console.error("No data to download.");
            return;
        }
        // Determine headers from the keys of the first object in the filtered data
        const headers = Object.keys(data[0]);

        // Convert the array of objects (data) to an array of arrays (AoA)
        const aoa = [
            headers,
            ...data.map(row => headers.map(header => row[header]))
        ];

        const ws = XLSX.utils.aoa_to_sheet(aoa);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "Report");
        XLSX.writeFile(wb, `${filename}.xlsx`);
    };

    // --- REACT COMPONENTS ---

    const FileUpload = ({ fileData, onFileChange, title, color }) => {
        const handleFileRead = (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const arrayBuffer = event.target.result;
                    const { json, headers } = processWorkbook(arrayBuffer);
                    
                    if (json.length === 0) {
                        alert(`File ${file.name} is empty or has no data rows.`);
                        return;
                    }

                    onFileChange({ 
                        name: file.name, 
                        headers: headers, 
                        data: json, 
                        idCol: null, 
                        amountCol: null 
                    });

                } catch (error) {
                    console.error("Error processing file:", error);
                    alert(`Failed to process file. Ensure it is a valid Excel/CSV format.`);
                }
            };
            reader.readAsArrayBuffer(file);
        };

        return (
            <div className={`border-2 border-dashed ${color} rounded-xl p-6 transition duration-300 hover:shadow-lg bg-white`}>
                <h2 className="text-xl font-bold mb-4 flex items-center text-gray-700">
                    <FileSpreadsheet size={24} className="mr-2 text-blue-500" />
                    {title}
                </h2>
                <input
                    type="file"
                    accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel"
                    onChange={handleFileRead}
                    className="hidden"
                    id={`file-upload-${title}`}
                />
                <label
                    htmlFor={`file-upload-${title}`}
                    className="flex flex-col items-center justify-center p-6 border-2 border-gray-300 rounded-lg cursor-pointer hover:bg-gray-50 transition duration-150"
                >
                    <Upload size={32} className="text-gray-500 mb-2" />
                    <span className="text-sm font-medium text-gray-600">
                        {fileData.name ? `Loaded: ${fileData.name}` : `Click to Upload Excel/CSV`}
                    </span>
                    {fileData.name && (
                        <span className="text-xs text-green-500 mt-1">
                            {fileData.data.length.toLocaleString()} rows detected.
                        </span>
                    )}
                </label>
            </div>
        );
    };

    const ColumnSelector = ({ fileData, setFileData, type, label }) => {
        const handleChange = (e) => {
            setFileData(prev => ({ ...prev, [type]: e.target.value }));
        };

        return (
            <div className="flex flex-col">
                <label className="text-sm font-medium text-gray-700 mb-1">{label}</label>
                <select
                    value={fileData[type] || ''}
                    onChange={handleChange}
                    className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md shadow-sm"
                    disabled={fileData.headers.length === 0}
                >
                    <option value="" disabled>Select a Column</option>
                    {fileData.headers.map(header => (
                        <option key={header} value={header}>{header}</option>
                    ))}
                </select>
            </div>
        );
    };

    const OutputColumnSelector = ({ allUniqueHeaders, selectedColumns, onToggleColumn }) => {
        // Headers that are mandatory and not selectable, but shown for context
        const mandatoryCols = MANDATORY_TRACEABILITY_COLUMNS;
        
        return (
            <div className="bg-white border border-gray-200 rounded-xl p-6 shadow-md">
                <h3 className="text-xl font-bold text-gray-800 mb-4 flex items-center">
                    <ListChecks size={24} className="mr-2 text-indigo-600" />
                    Select Report Detail Columns
                </h3>
                <p className="text-sm text-gray-600 mb-4">
                    Choose which additional columns from the source files should appear in the final **Matched** and **Unique** reports.
                </p>
                <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 max-h-60 overflow-y-auto p-2">
                    {allUniqueHeaders.map(header => (
                        <div key={header} className="flex items-center">
                            <input
                                id={`col-${header}`}
                                type="checkbox"
                                checked={selectedColumns.has(header)}
                                onChange={() => onToggleColumn(header)}
                                className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                            />
                            <label htmlFor={`col-${header}`} className="ml-2 text-sm text-gray-700 truncate" title={header}>
                                {header}
                            </label>
                        </div>
                    ))}
                </div>
                
                <div className="mt-4 pt-4 border-t border-gray-100">
                    <p className="text-xs text-gray-500">
                        *The following columns are **always** included for traceability: {mandatoryCols.join(', ')}
                    </p>
                </div>
            </div>
        );
    };

    const SummaryTable = ({ metrics, category }) => (
        <div className="bg-white border border-gray-200 rounded-lg p-4 shadow-sm">
            <h4 className="text-lg font-semibold text-gray-700 mb-3 border-b pb-2">{category} Metrics</h4>
            <dl className="space-y-2">
                {metrics.map((metric, index) => (
                    <div key={index} className="flex justify-between text-sm">
                        <dt className="font-medium text-gray-600">{metric.label}</dt>
                        <dd className="font-bold text-gray-800">{metric.value.toLocaleString()}</dd>
                    </div>
                ))}
            </dl>
        </div>
    );

    const ReconciliationApp = () => {
        const [step, setStep] = useState(1);
        const [fileDataA, setFileDataA] = useState(initialState);
        const [fileDataB, setFileDataB] = useState(initialState);
        const [results, setResults] = useState(null);
        const [isLoading, setIsLoading] = useState(false);
        const [selectedDownloads, setSelectedDownloads] = useState(new Set(['matched', 'uniqueA', 'uniqueB']));
        
        // NEW STATE for column selection
        const [selectedReportColumns, setSelectedReportColumns] = useState(new Set());


        // Step 1: Upload Files
        const isStep1Complete = fileDataA.data.length > 0 && fileDataB.data.length > 0;

        // Step 2: Configure Columns
        const isStep2Complete = fileDataA.idCol && fileDataA.amountCol && fileDataB.idCol && fileDataB.amountCol;

        // Calculate all unique headers for the selector (excluding keys and amounts)
        const allUniqueHeaders = useMemo(() => {
            if (step !== 2 || !fileDataA.headers.length || !fileDataB.headers.length) return [];

            const keysA = [fileDataA.idCol, fileDataA.amountCol].filter(Boolean);
            const keysB = [fileDataB.idCol, fileDataB.amountCol].filter(Boolean);

            const nonKeyHeadersA = fileDataA.headers.filter(h => !keysA.includes(h));
            const nonKeyHeadersB = fileDataB.headers.filter(h => !keysB.includes(h));

            const combinedHeaders = new Set([...nonKeyHeadersA, ...nonKeyHeadersB]);
            
            // Convert Set to Array for rendering
            return Array.from(combinedHeaders);
        }, [step, fileDataA, fileDataB]);

        // Effect to initialize selectedReportColumns when headers change
        useEffect(() => {
            if (step === 2 && allUniqueHeaders.length > 0) {
                 // Initialize with all unique non-key headers selected by default
                setSelectedReportColumns(new Set(allUniqueHeaders));
            }
        }, [step, allUniqueHeaders]);


        const handleRunReconciliation = useCallback(async () => {
            if (!isStep2Complete) return;

            setIsLoading(true);
            // Simulate a delay for complex calculation
            await new Promise(resolve => setTimeout(resolve, 50)); 

            try {
                // Pass the selected columns to the reconciliation logic
                const newResults = reconcileData(fileDataA, fileDataB, selectedReportColumns);
                setResults(newResults);
                setStep(3);
            } catch (error) {
                console.error("Reconciliation error:", error);
                alert("An error occurred during reconciliation. Check console for details.");
            } finally {
                setIsLoading(false);
            }
        }, [fileDataA, fileDataB, isStep2Complete, selectedReportColumns]);

        const handleToggleDownload = (key) => {
            setSelectedDownloads(prev => {
                const newSet = new Set(prev);
                if (newSet.has(key)) {
                    newSet.delete(key);
                } else {
                    newSet.add(key);
                }
                return newSet;
            });
        };

        const handleDownloadAll = () => {
            if (!results || selectedDownloads.size === 0) return;

            const downloads = {
                'matched': { data: results.matched, name: 'Reconciliation_Matched' },
                'uniqueA': { data: results.uniqueA, name: `Reconciliation_Unique_in_${fileDataA.name.split('.')[0]}` },
                'uniqueB': { data: results.uniqueB, name: `Reconciliation_Unique_in_${fileDataB.name.split('.')[0]}` },
            };

            selectedDownloads.forEach(key => {
                if (downloads[key] && downloads[key].data.length > 0) {
                    downloadExcel(downloads[key].data, downloads[key].name);
                }
            });
        };

        const handleToggleOutputColumn = useCallback((header) => {
            setSelectedReportColumns(prev => {
                const newSet = new Set(prev);
                if (newSet.has(header)) {
                    newSet.delete(header);
                } else {
                    newSet.add(header);
                }
                return newSet;
            });
        }, []);


        return (
            <div className="max-w-7xl mx-auto p-6 relative">
                <header className="py-6 mb-8 border-b border-gray-200">
                    <h1 className="text-3xl font-extrabold text-gray-900">Advanced Reconciliation Tool</h1>
                    <p className="text-gray-500 mt-1">Cross-reference two financial data files using a composite key (ID + Amount).</p>
                </header>

                <div className="bg-white rounded-xl shadow-2xl p-8 relative">
                    <div className="flex justify-between items-center mb-6">
                        <h2 className="text-2xl font-semibold text-gray-800">
                            Step {step}: {step === 1 ? "Upload Files" : step === 2 ? "Configure Matching Columns" : "Results & Download"}
                        </h2>
                        {step !== 3 && (
                            <div className="flex space-x-2">
                                <span className={`h-2 w-8 rounded-full ${step === 1 ? 'bg-blue-500' : 'bg-gray-300'}`}></span>
                                <span className={`h-2 w-8 rounded-full ${step === 2 ? 'bg-blue-500' : 'bg-gray-300'}`}></span>
                            </div>
                        )}
                    </div>

                    {isLoading && (
                        <div className="loading-overlay">
                            <div className="flex flex-col items-center">
                                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mb-3"></div>
                                <p className="text-lg font-medium text-blue-600">Running Reconciliation...</p>
                            </div>
                        </div>
                    )}

                    {/* Step 1: Upload Files */}
                    {step === 1 && (
                        <div className="grid md:grid-cols-2 gap-8">
                            <FileUpload 
                                fileData={fileDataA} 
                                onFileChange={setFileDataA} 
                                title="File A (Primary Source)" 
                                color="border-blue-300" 
                            />
                            <FileUpload 
                                fileData={fileDataB} 
                                onFileChange={setFileDataB} 
                                title="File B (Reference Source)" 
                                color="border-green-300" 
                            />
                            <div className="md:col-span-2 pt-4 flex justify-center">
                                <button
                                    onClick={() => setStep(2)}
                                    disabled={!isStep1Complete}
                                    className={`px-8 py-3 rounded-xl font-semibold text-white transition duration-200 ${isStep1Complete ? 'bg-blue-600 hover:bg-blue-700 shadow-md' : 'bg-gray-400 cursor-not-allowed'}`}
                                >
                                    Continue to Column Mapping
                                </button>
                            </div>
                        </div>
                    )}

                    {/* Step 2: Configure Columns */}
                    {step === 2 && (
                        <div className="space-y-8">
                            {/* Key Column Selection */}
                            <div className="grid md:grid-cols-2 gap-8 bg-gray-50 p-6 rounded-xl border border-gray-200">
                                <div>
                                    <h3 className="text-xl font-bold text-gray-700 mb-4">{fileDataA.name} Mapping</h3>
                                    <div className="space-y-4">
                                        <ColumnSelector 
                                            fileData={fileDataA} 
                                            setFileData={setFileDataA} 
                                            type="idCol" 
                                            label="Matching ID Column (e.g., Transaction Ref, Account No)" 
                                        />
                                        <ColumnSelector 
                                            fileData={fileDataA} 
                                            setFileData={setFileDataA} 
                                            type="amountCol" 
                                            label="Amount Column (e.g., Debit, Credit, Amount)" 
                                        />
                                    </div>
                                </div>
                                <div>
                                    <h3 className="text-xl font-bold text-gray-700 mb-4">{fileDataB.name} Mapping</h3>
                                    <div className="space-y-4">
                                        <ColumnSelector 
                                            fileData={fileDataB} 
                                            setFileData={setFileDataB} 
                                            type="idCol" 
                                            label="Matching ID Column (e.g., Transaction Ref, Account No)" 
                                        />
                                        <ColumnSelector 
                                            fileData={fileDataB} 
                                            setFileData={setFileDataB} 
                                            type="amountCol" 
                                            label="Amount Column (e.g., Debit, Credit, Amount)" 
                                        />
                                    </div>
                                </div>
                                <div className="md:col-span-2 bg-blue-50 border border-blue-200 rounded-lg p-3">
                                    <p className="text-sm text-blue-800 flex items-start">
                                        <Info size={18} className="mr-2 mt-0.5 flex-shrink-0 text-blue-600" />
                                        <span>
                                            Reconciliation will match rows only if both the **Matching ID** AND the **Amount** are identical across files.
                                        </span>
                                    </p>
                                </div>
                            </div>
                            
                            {/* Output Column Selection (NEW SECTION) */}
                            {allUniqueHeaders.length > 0 && (
                                <OutputColumnSelector
                                    allUniqueHeaders={allUniqueHeaders}
                                    selectedColumns={selectedReportColumns}
                                    onToggleColumn={handleToggleOutputColumn}
                                />
                            )}

                            <div className="pt-4 flex justify-center">
                                <button
                                    onClick={handleRunReconciliation}
                                    disabled={!isStep2Complete || isLoading || selectedReportColumns.size === 0}
                                    className={`px-8 py-3 rounded-xl font-semibold text-white transition duration-200 ${isStep2Complete && !isLoading && selectedReportColumns.size > 0 ? 'bg-green-600 hover:bg-green-700 shadow-md' : 'bg-gray-400 cursor-not-allowed'}`}
                                >
                                    Run Reconciliation
                                </button>
                            </div>
                        </div>
                    )}

                    {/* Step 3: Results & Download */}
                    {step === 3 && results && (
                        <div>
                            <div className="space-y-6 mb-8">
                                <h3 className="text-2xl font-bold text-green-700 flex items-center">
                                    <Download size={24} className="mr-2"/> Reconciliation Complete!
                                </h3>

                                {/* Download Options */}
                                <div className="bg-white border border-gray-200 rounded-xl p-6 shadow-md">
                                    <h4 className="text-lg font-semibold text-gray-700 mb-4">Select Reports to Download</h4>
                                    <div className="grid sm:grid-cols-3 gap-4 mb-4">
                                        {Object.entries({
                                            'matched': { label: 'Matched Records', count: results.matched.length, color: 'text-blue-600' },
                                            'uniqueA': { label: `Unique in ${fileDataA.name}`, count: results.uniqueA.length, color: 'text-red-600' },
                                            'uniqueB': { label: `Unique in ${fileDataB.name}`, count: results.uniqueB.length, color: 'text-red-600' },
                                        }).map(([key, { label, count, color }]) => (
                                            <label 
                                                key={key} 
                                                className={`flex items-center p-4 border rounded-lg cursor-pointer transition duration-150 ${selectedDownloads.has(key) ? 'border-indigo-500 bg-indigo-50 shadow-inner' : 'border-gray-300 hover:bg-gray-50'}`}
                                            >
                                                <input
                                                    type="checkbox"
                                                    checked={selectedDownloads.has(key)}
                                                    onChange={() => handleToggleDownload(key)}
                                                    className="h-5 w-5 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                                                />
                                                <div className="ml-3">
                                                    <span className="font-medium text-gray-700">{label}</span>
                                                    <p className={`text-sm font-bold ${color}`}>{count.toLocaleString()} rows</p>
                                                </div>
                                            </label>
                                        ))}
                                    </div>
                                    <button
                                        onClick={handleDownloadAll}
                                        disabled={selectedDownloads.size === 0}
                                        className={`w-full px-6 py-3 rounded-xl font-semibold text-white transition duration-200 flex items-center justify-center ${selectedDownloads.size > 0 ? 'bg-indigo-600 hover:bg-indigo-700' : 'bg-gray-400 cursor-not-allowed'}`}
                                    >
                                        <Download size={20} className="mr-2"/>
                                        Download ({selectedDownloads.size}) Report{selectedDownloads.size !== 1 ? 's' : ''}
                                    </button>
                                </div>

                                {/* Structured Summary Tables */}
                                <div className="bg-gray-50 rounded-lg p-6 border border-gray-200">
                                    <h3 className="font-bold text-xl mb-4 text-gray-800">Detailed Structured Summary</h3>
                                    <div className="grid md:grid-cols-2 gap-6">
                                        {/* Category A Summary */}
                                        <SummaryTable metrics={results.summaryMetricsA} category={fileDataA.name} />
                                        
                                        {/* Category B Summary */}
                                        <SummaryTable metrics={results.summaryMetricsB} category={fileDataB.name} />
                                    </div>
                                </div>

                                <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                                    <p className="text-sm text-blue-800 flex items-start">
                                        <Info size={18} className="mr-2 mt-0.5 flex-shrink-0 text-blue-600" />
                                        <span>
                                            **Traceability Note:** All generated data sheets include the **`__Composite_ID`** (the key used for matching, serialized to string), **`__Source_File`**, **`__Original_Row_Index`**, and **`__Appearance_Count`** columns for traceability and frequency analysis.
                                        </span>
                                    </p>
                                </div>

                                <div className="text-center pt-4">
                                    <button 
                                        onClick={() => { 
                                            setStep(1); 
                                            setResults(null); 
                                            setFileDataA(initialState); 
                                            setFileDataB(initialState); 
                                            setSelectedDownloads(new Set(['matched', 'uniqueA', 'uniqueB']));
                                            setSelectedReportColumns(new Set()); // Reset new state
                                        }} 
                                        className="px-6 py-3 border border-gray-300 text-gray-700 font-semibold rounded-lg hover:bg-gray-100 transition duration-200"
                                    >
                                        Start New Reconciliation
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            </div>
        );
    };
    
    // Render the React application
    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    root.render(<ReconciliationApp />);

    </script>
</body>
</html>
