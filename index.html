<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Reconciliation Tool (Layered ID Extraction)</title>
    <!-- Load React and ReactDOM from CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Load Babel for JSX transpilation in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load SheetJS/XLSX for Excel file handling -->
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
</head>
<body class="bg-gray-50 min-h-screen font-sans">
    <div id="root"></div>

    <script type="text/babel">
    // Destructure hooks from the global React object for easy access (FIX: addresses ReferenceError: useState is not defined)
    const { useState, useEffect, useCallback, useMemo } = React;
    
    // --- ICON PLACEHOLDERS (Replacing lucide-react imports for single-file HTML) ---
    const IconWrapper = ({ children, size = 20, className = '', color = 'currentColor' }) => (
        <span className={className} style={{ width: size, height: size, display: 'inline-flex', alignItems: 'center', justifyContent: 'center', color: color, flexShrink: 0 }}>{children}</span>
    );
    // Using Emojis or simple characters as placeholders
    const Upload = (props) => <IconWrapper {...props}><span role="img" aria-label="Upload">‚§í</span></IconWrapper>;
    const FileSpreadsheet = (props) => <IconWrapper {...props}><span role="img" aria-label="Spreadsheet">üßæ</span></IconWrapper>;
    const AlertCircle = (props) => <IconWrapper {...props} color="rgb(239 68 68)"><span role="img" aria-label="Error Alert">‚ö†Ô∏è</span></IconWrapper>; // Red
    const CheckCircle = (props) => <IconWrapper {...props} color="rgb(34 197 94)"><span role="img" aria-label="Success Check">‚úÖ</span></IconWrapper>; // Green
    const Download = (props) => <IconWrapper {...props}><span role="img" aria-label="Download">‚¨áÔ∏è</span></IconWrapper>;
    const X = (props) => <IconWrapper {...props}><span role="img" aria-label="Close">‚ùå</span></IconWrapper>;
    const Info = (props) => <IconWrapper {...props}><span role="img" aria-label="Info">‚ÑπÔ∏è</span></IconWrapper>;


    // --- UTILITY FUNCTIONS ---

    // Utility function to convert files to an array of objects
    const processFile = (file) => {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    const json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                    
                    if (json.length === 0) {
                        return reject(new Error(`File ${file.name} is empty or invalid.`));
                    }
                    
                    const headers = json[0];
                    const rows = json.slice(1);
                    
                    const processedData = rows.map((row, index) => {
                        const rowObject = {};
                        headers.forEach((header, i) => {
                            // Trim header and ensure keys are clean strings
                            const key = String(header).trim();
                            // If row value is undefined or null, default to empty string
                            rowObject[key] = row[i] !== undefined && row[i] !== null ? row[i] : ''; 
                        });
                        // Add original file name and row index for traceability
                        rowObject['__Source_File'] = file.name;
                        rowObject['__Original_Row_Index'] = index + 2; // +1 for 0-based index, +1 for header row
                        return rowObject;
                    });

                    resolve({ fileName: file.name, data: processedData, headers });

                } catch (error) {
                    reject(new Error(`Error processing ${file.name}: ${error.message}`));
                }
            };
            reader.onerror = (error) => reject(new Error(`File reading failed: ${error.message}`));
            reader.readAsArrayBuffer(file);
        });
    };

    // --- COMPONENTS ---

    // Component for displaying file upload status and removing files
    const FileList = ({ files, onRemove }) => (
        <ul className="space-y-2">
            {files.map((file, index) => (
                <li key={index} className="flex items-center justify-between p-2 bg-white border border-gray-200 rounded-lg text-sm">
                    <div className="flex items-center min-w-0 pr-4">
                        <FileSpreadsheet className="text-blue-500 mr-2" size={16} />
                        <span className="truncate font-medium text-gray-700" title={file.name}>{file.name}</span>
                    </div>
                    <button 
                        onClick={() => onRemove(index)}
                        className="p-1 rounded-full text-red-500 hover:bg-red-100 transition duration-150"
                        title="Remove file"
                    >
                        <X size={16} />
                    </button>
                </li>
            ))}
        </ul>
    );

    // Component for the main summary table
    const SummaryTable = ({ metrics, category }) => (
        <div className="bg-white border border-gray-200 rounded-xl shadow-sm p-4">
            <h4 className="text-lg font-semibold mb-3 text-gray-700">{category} Metrics</h4>
            <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-200">
                    <tbody className="divide-y divide-gray-100">
                        {metrics.map((metric, index) => (
                            <tr key={index} className={metric.value > 0 && metric.key.includes('Unmatched') ? 'bg-red-50' : ''}>
                                <td className="py-2 pr-4 text-sm font-medium text-gray-900">{metric.label}</td>
                                <td className="py-2 pl-4 text-sm font-semibold text-right text-gray-800">
                                    {metric.format === 'count' ? metric.value.toLocaleString() : 
                                     metric.value.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        </div>
    );


    // --- MAIN APP COMPONENT ---

    const ReconciliationApp = () => {
        // State variables
        const [step, setStep] = useState(1);
        const [categoryAFiles, setCategoryAFiles] = useState([]);
        const [categoryBFiles, setCategoryBFiles] = useState([]);
        const [columnConfig, setColumnConfig] = useState({
            uniqueIdA: '',
            uniqueIdB: '',
            amountA: '',
            amountB: ''
        });
        const [availableColumnsA, setAvailableColumnsA] = useState([]);
        const [availableColumnsB, setAvailableColumnsB] = useState([]);
        const [processing, setProcessing] = useState(false);
        const [results, setResults] = useState(null);
        const [error, setError] = useState(null);
        const [selectedDownloads, setSelectedDownloads] = useState(['summary', 'matched', 'unmatchedA', 'unmatchedB']);


        // --- HANDLERS ---

        const handleFileUpload = useCallback(async (e, category) => {
            setError(null);
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            const targetSetFiles = category === 'A' ? setCategoryAFiles : setCategoryBFiles;
            const targetSetColumns = category === 'A' ? setAvailableColumnsA : setAvailableColumnsB;
            const currentColumns = category === 'A' ? availableColumnsA : availableColumnsB;
            
            targetSetFiles(prev => [...prev, ...files]);

            // Only extract columns from the first file in a category
            if (currentColumns.length === 0) {
                try {
                    const { headers } = await processFile(files[0]);
                    // Filter out internal columns
                    const cleanHeaders = headers.filter(h => h && !String(h).startsWith('__')).map(h => String(h).trim()).filter(h => h.length > 0);
                    targetSetColumns(cleanHeaders);
                    
                    // Auto-select columns if possible (simple heuristic)
                    if (category === 'A') {
                        const autoId = cleanHeaders.find(h => h.toLowerCase().includes('ref') || h.toLowerCase().includes('id'));
                        const autoAmount = cleanHeaders.find(h => h.toLowerCase().includes('amount') || h.toLowerCase().includes('debit') || h.toLowerCase().includes('credit'));
                        setColumnConfig(prev => ({
                            ...prev,
                            uniqueIdA: autoId || '',
                            amountA: autoAmount || ''
                        }));
                    } else {
                        const autoId = cleanHeaders.find(h => h.toLowerCase().includes('ref') || h.toLowerCase().includes('id'));
                        const autoAmount = cleanHeaders.find(h => h.toLowerCase().includes('amount') || h.toLowerCase().includes('debit') || h.toLowerCase().includes('credit'));
                         setColumnConfig(prev => ({
                            ...prev,
                            uniqueIdB: autoId || '',
                            amountB: autoAmount || ''
                        }));
                    }

                } catch (err) {
                    setError(err.message);
                    targetSetFiles(prev => prev.filter(f => f.name !== files[0].name)); // Remove file if parsing failed
                }
            }
        }, [availableColumnsA, availableColumnsB]);

        const handleRemoveFile = useCallback((index, category) => {
            const targetSetFiles = category === 'A' ? setCategoryAFiles : setCategoryBFiles;
            targetSetFiles(prev => prev.filter((_, i) => i !== index));

            // If the last file is removed, clear column config and available columns
            if (category === 'A' && categoryAFiles.length === 1) {
                setAvailableColumnsA([]);
                setColumnConfig(prev => ({...prev, uniqueIdA: '', amountA: ''}));
            }
            if (category === 'B' && categoryBFiles.length === 1) {
                setAvailableColumnsB([]);
                setColumnConfig(prev => ({...prev, uniqueIdB: '', amountB: ''}));
            }
        }, [categoryAFiles, categoryBFiles]);

        const reconcileData = useCallback(async () => {
            setError(null);
            setProcessing(true);
            setResults(null);

            const { uniqueIdA, uniqueIdB, amountA, amountB } = columnConfig;

            if (!uniqueIdA || !uniqueIdB || !amountA || !amountB || categoryAFiles.length === 0 || categoryBFiles.length === 0) {
                setError("Please select files and configure all four required columns before reconciling.");
                setProcessing(false);
                return;
            }

            try {
                // 1. Process all files and consolidate data
                const aPromises = categoryAFiles.map(file => processFile(file));
                const bPromises = categoryBFiles.map(file => processFile(file));

                const allAPromises = await Promise.all(aPromises);
                const allBPromises = await Promise.all(bPromises);

                let allAData = [];
                allAPromises.forEach(p => { allAData = allAData.concat(p.data); });
                let allBData = [];
                allBPromises.forEach(p => { allBData = allBData.concat(p.data); });
                
                // Helper to create a unique ID for matching.
                const generateCompositeID = (row, uniqueCol, amountCol) => {
                    const uniqueVal = String(row[uniqueCol]).trim().toUpperCase();
                    // Normalize amount: round to 2 decimal places and ensure it's a number
                    const amountVal = (typeof row[amountCol] === 'number' ? row[amountCol] : parseFloat(String(row[amountCol]).replace(/[^0-9.-]/g, '')) || 0);
                    const roundedAmount = parseFloat(amountVal.toFixed(2));
                    
                    // Create a composite key: UniqueID + Amount (rounded)
                    return `${uniqueVal}_${roundedAmount}`;
                };

                // Helper to map and prepare data
                const prepareData = (data, uniqueCol, amountCol, category) => {
                    const map = new Map();
                    data.forEach(row => {
                        const compositeID = generateCompositeID(row, uniqueCol, amountCol);
                        const amount = (typeof row[amountCol] === 'number' ? row[amountCol] : parseFloat(String(row[amountCol]).replace(/[^0-9.-]/g, '')) || 0);

                        if (!map.has(compositeID)) {
                            map.set(compositeID, {
                                compositeID,
                                amount: parseFloat(amount.toFixed(2)),
                                count: 0,
                                source: category,
                                records: []
                            });
                        }
                        
                        const entry = map.get(compositeID);
                        entry.count++;
                        entry.records.push({
                            ...row,
                            [`${category}_Amount`]: parseFloat(amount.toFixed(2)),
                            [`${category}_Unique_ID`]: row[uniqueCol],
                            '__Composite_ID': compositeID,
                            '__Appearance_Count': entry.count,
                        });
                    });
                    return Array.from(map.values());
                };
                
                const preparedA = prepareData(allAData, uniqueIdA, amountA, 'A');
                const preparedB = prepareData(allBData, uniqueIdB, amountB, 'B');

                // 2. Perform Reconciliation
                let matched = [];
                let unmatchedA = [];
                let unmatchedB = [];
                
                const bMap = new Map(preparedB.map(item => [item.compositeID, item]));

                preparedA.forEach(aItem => {
                    const bItem = bMap.get(aItem.compositeID);

                    if (bItem) {
                        // Match Found
                        
                        // Handle the case where the composite ID appeared multiple times in both
                        const minCount = Math.min(aItem.count, bItem.count);
                        const maxCount = Math.max(aItem.count, bItem.count);
                        
                        // Combine records up to the minimum count
                        for (let i = 0; i < minCount; i++) {
                             // Combine the current records from A and B
                            const aRecord = aItem.records[i];
                            const bRecord = bItem.records[i];
                            matched.push({
                                // Metadata for download report
                                '__Match_Status': 'MATCHED',
                                '__Source_File_A': aRecord['__Source_File'],
                                '__Source_File_B': bRecord['__Source_File'],
                                '__Original_Row_Index_A': aRecord['__Original_Row_Index'],
                                '__Original_Row_Index_B': bRecord['__Original_Row_Index'],
                                
                                // User Data Fields
                                'Composite_ID': aItem.compositeID,
                                'Amount': aItem.amount,
                                'Unique_ID_A': aRecord[`A_Unique_ID`],
                                'Amount_A': aRecord[`A_Amount`],
                                'Unique_ID_B': bRecord[`B_Unique_ID`],
                                'Amount_B': bRecord[`B_Amount`],
                                'Difference': aItem.amount - bItem.amount, // Should be 0
                                
                                // Merge all other original fields from both records (prefixed)
                                ...Object.entries(aRecord)
                                    .filter(([key]) => !key.startsWith('__') && key !== uniqueIdA && key !== amountA)
                                    .reduce((acc, [key, value]) => ({...acc, [`A_${key}`]: value}), {}),
                                ...Object.entries(bRecord)
                                    .filter(([key]) => !key.startsWith('__') && key !== uniqueIdB && key !== amountB)
                                    .reduce((acc, [key, value]) => ({...acc, [`B_${key}`]: value}), {}),

                            });
                        }
                        
                        // Handle leftovers (Partial Match, but records still unmatched)
                        if (aItem.count > minCount) {
                            for (let i = minCount; i < aItem.count; i++) {
                                const aRecord = aItem.records[i];
                                unmatchedA.push({
                                    ...aRecord,
                                    '__Match_Status': 'UNMATCHED_LEFTOVER',
                                    'Composite_ID': aItem.compositeID,
                                    'Amount': aItem.amount,
                                });
                            }
                        }
                        if (bItem.count > minCount) {
                            for (let i = minCount; i < bItem.count; i++) {
                                const bRecord = bItem.records[i];
                                unmatchedB.push({
                                    ...bRecord,
                                    '__Match_Status': 'UNMATCHED_LEFTOVER',
                                    'Composite_ID': bItem.compositeID,
                                    'Amount': bItem.amount,
                                });
                            }
                        }
                        
                        // Remove from B map so it's not checked again
                        bMap.delete(aItem.compositeID); 

                    } else {
                        // No Match found in B for this Composite ID (Category A Only)
                        unmatchedA = unmatchedA.concat(aItem.records.map(r => ({
                            ...r,
                            '__Match_Status': 'UNMATCHED_A_ONLY',
                            'Composite_ID': aItem.compositeID,
                            'Amount': aItem.amount,
                        })));
                    }
                });

                // All remaining items in bMap are Category B Only
                bMap.forEach(bItem => {
                    unmatchedB = unmatchedB.concat(bItem.records.map(r => ({
                        ...r,
                        '__Match_Status': 'UNMATCHED_B_ONLY',
                        'Composite_ID': bItem.compositeID,
                        'Amount': bItem.amount,
                    })));
                });
                
                // --- GENERATE SUMMARY ---
                const totalA = preparedA.reduce((sum, item) => sum + item.amount * item.count, 0);
                const countA = preparedA.reduce((sum, item) => sum + item.count, 0);
                const totalB = preparedB.reduce((sum, item) => sum + item.amount * item.count, 0);
                const countB = preparedB.reduce((sum, item) => sum + item.count, 0);

                const matchedCount = matched.length;
                const matchedAmount = matched.reduce((sum, item) => sum + item.Amount, 0);
                const unmatchedACount = unmatchedA.length;
                const unmatchedAAmount = unmatchedA.reduce((sum, item) => sum + item.Amount, 0);
                const unmatchedBCount = unmatchedB.length;
                const unmatchedBAmount = unmatchedB.reduce((sum, item) => sum + item.Amount, 0);
                
                const overallStatus = (countA === matchedCount && countB === matchedCount) ? 'Perfect Match' : 
                                      (matchedCount > 0 && (unmatchedACount > 0 || unmatchedBCount > 0)) ? 'Partial Match' : 
                                      (matchedCount === 0) ? 'No Match' : 'Perfect Match';


                const summaryMetricsA = [
                    { key: 'totalA', label: 'Total Records Uploaded', value: countA, format: 'count' },
                    { key: 'totalAmountA', label: 'Total Amount (A)', value: totalA, format: 'currency' },
                    { key: 'matchedA', label: 'Matched Records (Count)', value: matchedCount, format: 'count' },
                    { key: 'matchedAmountA', label: 'Matched Amount', value: matchedAmount, format: 'currency' },
                    { key: 'unmatchedA', label: 'Unmatched Records (A Only)', value: unmatchedACount, format: 'count' },
                    { key: 'unmatchedAmountA', label: 'Unmatched Amount (A Only)', value: unmatchedAAmount, format: 'currency' },
                ];

                const summaryMetricsB = [
                    { key: 'totalB', label: 'Total Records Uploaded', value: countB, format: 'count' },
                    { key: 'totalAmountB', label: 'Total Amount (B)', value: totalB, format: 'currency' },
                    { key: 'matchedB', label: 'Matched Records (Count)', value: matchedCount, format: 'count' },
                    { key: 'matchedAmountB', label: 'Matched Amount', value: matchedAmount, format: 'currency' },
                    { key: 'unmatchedB', label: 'Unmatched Records (B Only)', value: unmatchedBCount, format: 'count' },
                    { key: 'unmatchedAmountB', label: 'Unmatched Amount (B Only)', value: unmatchedBAmount, format: 'currency' },
                ];


                setResults({
                    overallStatus,
                    matched: matched,
                    unmatchedA: unmatchedA,
                    unmatchedB: unmatchedB,
                    summaryMetricsA,
                    summaryMetricsB,
                });
                setStep(3); // Move to results step

            } catch (err) {
                console.error("Reconciliation Error:", err);
                setError(`A critical error occurred during reconciliation: ${err.message}. Please check your files and column names.`);
            } finally {
                setProcessing(false);
            }
        }, [columnConfig, categoryAFiles, categoryBFiles]);

        const downloadReport = useCallback(() => {
            const wb = XLSX.utils.book_new();
            const dateStr = new Date().toISOString().slice(0, 10);
            
            const reportsToGenerate = {
                'summary': { 
                    sheetName: 'Summary', 
                    data: [
                        ...results.summaryMetricsA.map(m => ({
                            Category: `A - ${m.label}`,
                            Count: m.format === 'count' ? m.value : null,
                            Amount: m.format === 'currency' ? m.value : null,
                        })),
                        ...results.summaryMetricsB.map(m => ({
                            Category: `B - ${m.label}`,
                            Count: m.format === 'count' ? m.value : null,
                            Amount: m.format === 'currency' ? m.value : null,
                        })),
                        { Category: 'Overall Status', Count: null, Amount: results.overallStatus }
                    ], 
                    active: selectedDownloads.includes('summary') 
                },
                'matched': { 
                    sheetName: 'Matched Records', 
                    data: results.matched, 
                    active: selectedDownloads.includes('matched') 
                },
                'unmatchedA': { 
                    sheetName: 'Unmatched A', 
                    data: results.unmatchedA, 
                    active: selectedDownloads.includes('unmatchedA') 
                },
                'unmatchedB': { 
                    sheetName: 'Unmatched B', 
                    data: results.unmatchedB, 
                    active: selectedDownloads.includes('unmatchedB') 
                },
            };

            Object.entries(reportsToGenerate).forEach(([key, report]) => {
                if (report.active) {
                    const ws = XLSX.utils.json_to_sheet(report.data);
                    XLSX.utils.book_append_sheet(wb, ws, report.sheetName);
                }
            });

            if (wb.SheetNames.length === 0) {
                 setError("Please select at least one report type to download.");
                 return;
            }

            XLSX.writeFile(wb, `Reconciliation_Report_${dateStr}.xlsx`);
        }, [results, selectedDownloads]);


        // --- UI RENDER LOGIC ---

        const isConfigValid = useMemo(() => {
            const { uniqueIdA, uniqueIdB, amountA, amountB } = columnConfig;
            return uniqueIdA && uniqueIdB && amountA && amountB && categoryAFiles.length > 0 && categoryBFiles.length > 0;
        }, [columnConfig, categoryAFiles, categoryBFiles]);

        return (
            <div className="p-4 sm:p-8 max-w-6xl mx-auto">
                <header className="text-center mb-10">
                    <h1 className="text-3xl sm:text-4xl font-extrabold text-gray-800">
                        Advanced Transaction Reconciliation
                    </h1>
                    <p className="text-lg text-gray-500 mt-2">
                        Match records across two categories based on a Composite ID (Unique Ref + Amount).
                    </p>
                </header>

                <div className="bg-white p-6 sm:p-8 rounded-2xl shadow-xl border border-gray-100">
                    
                    {/* Step Indicators */}
                    <div className="flex justify-between items-center mb-8 relative">
                        {[1, 2, 3].map((s) => (
                            <React.Fragment key={s}>
                                <div className={`relative z-10 w-10 h-10 rounded-full flex items-center justify-center font-bold text-white transition-all duration-300 ${step >= s ? 'bg-indigo-600' : 'bg-gray-300'}`}>
                                    {s}
                                </div>
                                {s < 3 && (
                                    <div className={`flex-1 h-1 mx-2 transition-all duration-300 ${step > s ? 'bg-indigo-600' : 'bg-gray-300'}`}></div>
                                )}
                            </React.Fragment>
                        ))}
                        <div className="absolute top-1/2 left-0 right-0 h-1 bg-gray-300 transform -translate-y-1/2 -z-0"></div>
                    </div>
                    <div className="flex justify-between text-sm sm:text-base mb-10 text-gray-600 font-medium">
                        <span className={step === 1 ? 'text-indigo-600 font-semibold' : ''}>1. Upload Files</span>
                        <span className={step === 2 ? 'text-indigo-600 font-semibold' : ''}>2. Configure Columns</span>
                        <span className={step === 3 ? 'text-indigo-600 font-semibold' : ''}>3. Results & Download</span>
                    </div>


                    {/* Error Message Display */}
                    {error && (
                        <div className="p-4 mb-6 bg-red-100 border border-red-400 text-red-700 rounded-lg flex items-start">
                            <AlertCircle size={20} className="mt-0.5 mr-3 flex-shrink-0" />
                            <div className="text-sm">
                                <h4 className="font-bold">Operation Failed</h4>
                                <p>{error}</p>
                            </div>
                            <button onClick={() => setError(null)} className="ml-auto p-1 rounded-full text-red-500 hover:bg-red-200 transition"><X size={16} /></button>
                        </div>
                    )}

                    {/* STEP 1: Upload Files */}
                    {step === 1 && (
                        <div className="space-y-8">
                            <div className="grid md:grid-cols-2 gap-8">
                                {/* Category A Upload (e.g., GL Statement) */}
                                <div className="bg-gray-50 p-6 rounded-xl border border-dashed border-gray-300">
                                    <h3 className="text-xl font-semibold text-gray-700 mb-4 flex items-center">
                                        Category A: GL Statement / Core System Records
                                    </h3>
                                    <label className="block w-full text-center py-4 px-4 border-2 border-indigo-400 border-dashed rounded-lg cursor-pointer hover:bg-indigo-50 transition-colors">
                                        <Upload size={24} className="text-indigo-600 mx-auto mb-2" />
                                        <span className="text-indigo-600 font-medium">Select Excel Files (.xlsx)</span>
                                        <input type="file" multiple accept=".xlsx, .xls" className="hidden" onChange={(e) => handleFileUpload(e, 'A')} />
                                    </label>
                                    <p className="text-sm text-gray-500 mt-2">Selected Files: {categoryAFiles.length}</p>
                                    <div className="mt-4">
                                        <FileList files={categoryAFiles} onRemove={(idx) => handleRemoveFile(idx, 'A')} />
                                    </div>
                                </div>

                                {/* Category B Upload (e.g., Settlement Report) */}
                                <div className="bg-gray-50 p-6 rounded-xl border border-dashed border-gray-300">
                                    <h3 className="text-xl font-semibold text-gray-700 mb-4 flex items-center">
                                        Category B: Settlement / External System Report
                                    </h3>
                                    <label className="block w-full text-center py-4 px-4 border-2 border-indigo-400 border-dashed rounded-lg cursor-pointer hover:bg-indigo-50 transition-colors">
                                        <Upload size={24} className="text-indigo-600 mx-auto mb-2" />
                                        <span className="text-indigo-600 font-medium">Select Excel Files (.xlsx)</span>
                                        <input type="file" multiple accept=".xlsx, .xls" className="hidden" onChange={(e) => handleFileUpload(e, 'B')} />
                                    </label>
                                    <p className="text-sm text-gray-500 mt-2">Selected Files: {categoryBFiles.length}</p>
                                    <div className="mt-4">
                                        <FileList files={categoryBFiles} onRemove={(idx) => handleRemoveFile(idx, 'B')} />
                                    </div>
                                </div>
                            </div>
                            
                            <div className="text-center pt-4">
                                <button 
                                    onClick={() => setStep(2)} 
                                    disabled={categoryAFiles.length === 0 || categoryBFiles.length === 0}
                                    className="px-8 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-lg hover:bg-indigo-700 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
                                >
                                    Proceed to Column Configuration
                                </button>
                            </div>
                        </div>
                    )}

                    {/* STEP 2: Configure Columns */}
                    {step === 2 && (
                        <div className="space-y-8">
                            <p className="text-gray-600 text-center mb-6">
                                Select the Unique ID and Amount columns from your uploaded files.
                                The **Composite ID** will be generated by combining **Unique ID + Rounded Amount** for precise matching.
                            </p>
                            
                            <div className="grid md:grid-cols-2 gap-8">
                                {/* Category A Configuration */}
                                <div className="bg-gray-50 p-6 rounded-xl border border-gray-200 space-y-4">
                                    <h3 className="text-xl font-semibold text-gray-700 mb-4">Category A Columns</h3>
                                    
                                    <label className="block">
                                        <span className="text-gray-700 font-medium">Unique Identifier Column (A):</span>
                                        <select
                                            value={columnConfig.uniqueIdA}
                                            onChange={(e) => setColumnConfig(prev => ({ ...prev, uniqueIdA: e.target.value }))}
                                            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 bg-white text-gray-800"
                                            disabled={availableColumnsA.length === 0}
                                        >
                                            <option value="">-- Select Unique ID Column --</option>
                                            {availableColumnsA.map(col => <option key={col} value={col}>{col}</option>)}
                                        </select>
                                    </label>
                                    
                                    <label className="block">
                                        <span className="text-gray-700 font-medium">Amount Column (A):</span>
                                        <select
                                            value={columnConfig.amountA}
                                            onChange={(e) => setColumnConfig(prev => ({ ...prev, amountA: e.target.value }))}
                                            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 bg-white text-gray-800"
                                            disabled={availableColumnsA.length === 0}
                                        >
                                            <option value="">-- Select Amount Column --</option>
                                            {availableColumnsA.map(col => <option key={col} value={col}>{col}</option>)}
                                        </select>
                                    </label>
                                    {availableColumnsA.length === 0 && <p className="text-red-500 text-sm">Upload a file to load columns.</p>}
                                </div>

                                {/* Category B Configuration */}
                                <div className="bg-gray-50 p-6 rounded-xl border border-gray-200 space-y-4">
                                    <h3 className="text-xl font-semibold text-gray-700 mb-4">Category B Columns</h3>
                                    
                                    <label className="block">
                                        <span className="text-gray-700 font-medium">Unique Identifier Column (B):</span>
                                        <select
                                            value={columnConfig.uniqueIdB}
                                            onChange={(e) => setColumnConfig(prev => ({ ...prev, uniqueIdB: e.target.value }))}
                                            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 bg-white text-gray-800"
                                            disabled={availableColumnsB.length === 0}
                                        >
                                            <option value="">-- Select Unique ID Column --</option>
                                            {availableColumnsB.map(col => <option key={col} value={col}>{col}</option>)}
                                        </select>
                                    </label>
                                    
                                    <label className="block">
                                        <span className="text-gray-700 font-medium">Amount Column (B):</span>
                                        <select
                                            value={columnConfig.amountB}
                                            onChange={(e) => setColumnConfig(prev => ({ ...prev, amountB: e.target.value }))}
                                            className="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 bg-white text-gray-800"
                                            disabled={availableColumnsB.length === 0}
                                        >
                                            <option value="">-- Select Amount Column --</option>
                                            {availableColumnsB.map(col => <option key={col} value={col}>{col}</option>)}
                                        </select>
                                    </label>
                                    {availableColumnsB.length === 0 && <p className="text-red-500 text-sm">Upload a file to load columns.</p>}
                                </div>
                            </div>
                            
                            <div className="flex justify-center space-x-4 pt-4">
                                <button 
                                    onClick={() => setStep(1)} 
                                    className="px-6 py-3 border border-gray-300 text-gray-700 font-semibold rounded-lg hover:bg-gray-100 transition duration-200"
                                >
                                    ‚Üê Back to Upload
                                </button>
                                <button 
                                    onClick={reconcileData} 
                                    disabled={!isConfigValid || processing}
                                    className="px-8 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-lg hover:bg-indigo-700 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center"
                                >
                                    {processing ? (
                                        <>
                                            <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                            </svg>
                                            Processing...
                                        </>
                                    ) : (
                                        <>
                                            Reconcile & View Results
                                            <CheckCircle size={20} className="ml-2" color="white" />
                                        </>
                                    )}
                                </button>
                            </div>
                        </div>
                    )}

                    {/* STEP 3: Results */}
                    {step === 3 && results && (
                        <div className="space-y-8">
                            
                            <div className={`p-6 rounded-xl text-center shadow-lg ${results.overallStatus === 'Perfect Match' ? 'bg-green-100 border-green-500' : results.overallStatus === 'Partial Match' ? 'bg-yellow-100 border-yellow-500' : 'bg-red-100 border-red-500'}`}>
                                <h2 className="text-2xl sm:text-3xl font-bold mb-2 text-gray-800">
                                    Reconciliation Status: <span className={results.overallStatus === 'Perfect Match' ? 'text-green-700' : results.overallStatus === 'Partial Match' ? 'text-yellow-700' : 'text-red-700'}>{results.overallStatus}</span>
                                </h2>
                                <p className="text-lg text-gray-600">
                                    Matched Records: <span className="font-bold text-indigo-600">{results.matched.length.toLocaleString()}</span>
                                    {' / '}
                                    Total A: <span className="font-bold text-gray-700">{results.summaryMetricsA[0].value.toLocaleString()}</span>
                                    {' / '}
                                    Total B: <span className="font-bold text-gray-700">{results.summaryMetricsB[0].value.toLocaleString()}</span>
                                </p>
                            </div>

                            {/* Download Controls */}
                            <div className="bg-white p-6 rounded-xl border border-gray-200">
                                <h3 className="font-bold text-xl mb-4 text-gray-800 flex items-center">
                                    <Download size={24} className="mr-2 text-indigo-600" />
                                    Download Reports
                                </h3>
                                
                                <div className="grid grid-cols-2 sm:grid-cols-4 gap-4 mb-6">
                                    {Object.entries({
                                        summary: 'Summary',
                                        matched: 'Matched Records',
                                        unmatchedA: 'Unmatched A',
                                        unmatchedB: 'Unmatched B'
                                    }).map(([key, label]) => (
                                        <label key={key} className="flex items-center cursor-pointer bg-gray-50 p-3 rounded-lg border border-gray-200 hover:bg-gray-100 transition-colors">
                                            <input 
                                                type="checkbox" 
                                                checked={selectedDownloads.includes(key)}
                                                onChange={(e) => {
                                                    setSelectedDownloads(prev => 
                                                        e.target.checked ? [...prev, key] : prev.filter(k => k !== key)
                                                    );
                                                }}
                                                className="form-checkbox h-5 w-5 text-indigo-600 rounded border-gray-300"
                                            />
                                            <span className="ml-2 text-sm font-medium text-gray-700">{label}</span>
                                        </label>
                                    ))}
                                </div>
                                
                                <button
                                    onClick={downloadReport}
                                    disabled={selectedDownloads.length === 0}
                                    className="w-full py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center"
                                >
                                    <Download size={20} className="mr-2" />
                                    Download {selectedDownloads.length} Report{selectedDownloads.length !== 1 ? 's' : ''}
                                </button>
                            </div>


                            {/* Structured Summary Tables */}
                            <div className="bg-gray-50 rounded-lg p-6">
                                <h3 className="font-bold text-xl mb-4 text-gray-800">Detailed Structured Summary</h3>
                                <div className="grid md:grid-cols-2 gap-6">
                                    {/* Category A Summary */}
                                    <SummaryTable metrics={results.summaryMetricsA} category="Category A" />
                                    
                                    {/* Category B Summary */}
                                    <SummaryTable metrics={results.summaryMetricsB} category="Category B" />
                                </div>
                            </div>

                            <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                                <p className="text-sm text-blue-800 flex items-start">
                                    <Info size={18} className="mr-2 mt-0.5 flex-shrink-0 text-blue-600" />
                                    <span>
                                        **Traceability Note:** The downloaded reports include essential metadata like **`Composite_ID`** (for the match key), **`__Source_File`**, and **`__Original_Row_Index`** (for the exact row number in the source file) to help you trace the transaction back to its origin.
                                    </span>
                                </p>
                            </div>
                            <div className="text-center pt-4">
                                <button 
                                    onClick={() => setStep(1)} 
                                    className="px-6 py-3 border border-gray-300 text-gray-700 font-semibold rounded-lg hover:bg-gray-100 transition duration-200"
                                >
                                    Start New Reconciliation
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            </div>
        );
    };
    
    // Render the React application
    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    root.render(<ReconciliationApp />);

    </script>
</body>
</html>
