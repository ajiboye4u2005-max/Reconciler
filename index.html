<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Reconciliation Tool (Selective Column Output)</title>
    <!-- Load React and ReactDOM from CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Load Babel for JSX transpilation in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load SheetJS/XLSX for Excel file handling -->
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
    <style>
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            border-radius: 0.5rem;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen font-sans">
    <div id="root"></div>

    <script type="text/babel">
    // Destructure hooks from the global React object for easy access
    const { useState, useEffect, useCallback, useMemo } = React;
    
    // --- ICON PLACEHOLDERS (Replacing lucide-react imports for single-file HTML) ---
    const IconWrapper = ({ children, size = 20, className = '', color = 'currentColor' }) => (
        <span className={className} style={{ width: size, height: size, display: 'inline-flex', alignItems: 'center', justifyContent: 'center', color: color }}>{children}</span>
    );
    const Upload = (props) => <IconWrapper {...props}><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg></IconWrapper>;
    const FileSpreadsheet = (props) => <IconWrapper {...props}><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M8 13h2"/><path d="M8 17h2"/><path d="M14 13h2"/><path d="M14 17h2"/></svg></IconWrapper>;
    const Info = (props) => <IconWrapper {...props}><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg></IconWrapper>;
    const CheckCheck = (props) => <IconWrapper {...props}><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M8 12l2 2 4-4"/><path d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2z"/></svg></IconWrapper>;
    const Download = (props) => <IconWrapper {...props}><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg></IconWrapper>;

    const TRACE_COLS = ['__Composite_ID', '__Source_File', '__Original_Row_Index', '__Appearance_Count'];

    const initialState = {
        name: null,
        headers: [],
        data: [],
        idCol: null,
        amountCol: null,
    };

    // Helper component to display summary metrics in a table format
    const SummaryTable = ({ metrics, category }) => {
        const data = [
            { label: `Total Consolidated`, count: metrics.totalCount, amount: metrics.totalAmount },
            { label: `Matched`, count: metrics.matchedCount, amount: metrics.matchedAmount },
            { label: `Unmatched`, count: metrics.unmatchedCount, amount: metrics.unmatchedAmount, className: 'bg-red-50 text-red-800 font-semibold' },
        ];
        
        // Format numbers for display
        const formatNumber = (num) => (typeof num === 'number' ? num.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : '-');

        return (
            <div className="bg-white rounded-lg shadow-md overflow-hidden border border-gray-200">
                <div className="px-4 py-3 bg-gray-100 border-b border-gray-200">
                    <h4 className="text-lg font-bold text-gray-700">{category} Metrics</h4>
                </div>
                <table className="min-w-full divide-y divide-gray-200">
                    <thead className="bg-gray-50">
                        <tr>
                            <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                            <th className="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Count</th>
                            <th className="px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Amount</th>
                        </tr>
                    </thead>
                    <tbody className="bg-white divide-y divide-gray-200">
                        {data.map((row, index) => (
                            <tr key={index} className={row.className || 'hover:bg-gray-50'}>
                                <td className="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">{row.label}</td>
                                <td className="px-4 py-2 whitespace-nowrap text-sm text-right font-mono">{row.count.toLocaleString()}</td>
                                <td className="px-4 py-2 whitespace-nowrap text-sm text-right font-mono">{formatNumber(row.amount)}</td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        );
    };

    // Helper function to read Excel/CSV file using SheetJS
    const readExcelFile = (file) => {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    // Convert sheet to array of objects, keeping header row
                    const json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                    
                    if (json.length === 0) {
                        return reject(new Error("The file is empty or could not be parsed."));
                    }

                    const headers = json[0].map(h => (h || '').toString().trim());
                    const records = json.slice(1).map((row, index) => {
                        const record = {};
                        headers.forEach((header, i) => {
                            // Assign value, defaulting to null/empty string if undefined
                            record[header] = row[i] === undefined ? '' : row[i];
                        });
                        // Add original row index for traceability
                        record['__Original_Row_Index'] = index + 2; // +2 for 1-based index and skipping header row
                        return record;
                    });

                    resolve({ name: file.name, headers, data: records });
                } catch (error) {
                    reject(new Error(`Error parsing file ${file.name}: ${error.message}`));
                }
            };
            reader.onerror = (error) => reject(new Error(`File read error: ${error.target.error}`));
            reader.readAsArrayBuffer(file);
        });
    };

    // Component for column selection (Step 2)
    const ColumnSelector = ({ category, headers, selectedCols, setSelectedCols }) => {
        const toggleColumn = (header) => {
            setSelectedCols(prev => 
                prev.includes(header)
                    ? prev.filter(col => col !== header)
                    : [...prev, header]
            );
        };

        return (
            <div className="mt-4 p-4 border border-gray-200 rounded-lg bg-white shadow-sm">
                <h4 className="text-md font-semibold text-gray-700 mb-3">Select Columns for {category} Report Output</h4>
                <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-x-4 gap-y-2 max-h-60 overflow-y-auto p-2">
                    {headers.map(header => (
                        <label key={header} className="flex items-center space-x-2 text-sm cursor-pointer hover:bg-gray-50 p-1 rounded-md">
                            <input
                                type="checkbox"
                                checked={selectedCols.includes(header)}
                                onChange={() => toggleColumn(header)}
                                className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                            />
                            <span className="text-gray-600 truncate" title={header}>{header}</span>
                        </label>
                    ))}
                </div>
                <p className="mt-3 text-xs text-gray-500">
                    *The primary trace columns (e.g., `__Composite_ID`, `__Source_File`, `__Original_Row_Index`, `__Appearance_Count`) will **always** be included in the output for traceability, regardless of this selection.
                </p>
            </div>
        );
    };

    const ReconciliationApp = () => {
        const [step, setStep] = useState(1); // 1: Upload, 2: Configure, 3: Results
        const [fileDataA, setFileDataA] = useState(initialState);
        const [fileDataB, setFileDataB] = useState(initialState);
        const [results, setResults] = useState(null);
        const [loading, setLoading] = useState(false);
        const [error, setError] = useState(null);
        
        // New state for column selection
        const [selectedColsA, setSelectedColsA] = useState([]);
        const [selectedColsB, setSelectedColsB] = useState([]);

        // New state for download selection
        const downloadOptions = useMemo(() => ([
            { id: 'Summary', name: 'Summary Report', fileName: 'Summary.xlsx' },
            { id: 'A_Matched', name: 'Category A Matched', fileName: 'A_Matched.xlsx' },
            { id: 'A_Unmatched', name: 'Category A Unmatched', fileName: 'A_Unmatched.xlsx' },
            { id: 'B_Matched', name: 'Category B Matched', fileName: 'B_Matched.xlsx' },
            { id: 'B_Unmatched', name: 'Category B Unmatched', fileName: 'B_Unmatched.xlsx' },
        ]), []);
        const [selectedDownloads, setSelectedDownloads] = useState(['Summary']);


        const handleFileUpload = useCallback(async (event, setFileData, isA = true) => {
            const file = event.target.files[0];
            if (!file) return;

            setLoading(true);
            setError(null);

            try {
                const data = await readExcelFile(file);
                
                // Initialize selected columns with ALL original headers
                if (isA) {
                    setSelectedColsA(data.headers);
                } else {
                    setSelectedColsB(data.headers);
                }

                setFileData(data);
                if (fileDataA.name && !isA || fileDataB.name && isA) {
                    setStep(2); // Move to config step once both are uploaded (or one is uploaded and the other is already there)
                }

            } catch (err) {
                setError(err.message);
            } finally {
                setLoading(false);
            }
        }, [fileDataA.name, fileDataB.name]);


        const performReconciliation = useCallback(() => {
            setLoading(true);
            setError(null);
            
            if (!fileDataA.idCol || !fileDataA.amountCol || !fileDataB.idCol || !fileDataB.amountCol) {
                setError("Please select ID and Amount columns for both files.");
                setLoading(false);
                return;
            }

            // --- RECONCILIATION LOGIC ---
            const allData = [...fileDataA.data, ...fileDataB.data];
            const consolidatedMap = new Map();

            // 1. Consolidated Pass
            for (const item of allData) {
                const isA = item.__Source_File === fileDataA.name;
                const idCol = isA ? fileDataA.idCol : fileDataB.idCol;
                const amountCol = isA ? fileDataA.amountCol : fileDataB.amountCol;

                // Create a composite key (ensure it's a string for Map keys)
                const compositeId = `${item[idCol]}|${item[amountCol]}|${isA ? 'A' : 'B'}`;
                const matchKey = item[idCol]; // Key for cross-file matching

                if (!consolidatedMap.has(compositeId)) {
                    consolidatedMap.set(compositeId, {
                        ...item,
                        __Composite_ID: compositeId,
                        __Source_File: item.name,
                        __Match_Key: matchKey,
                        __Appearance_Count: 0,
                    });
                }
                consolidatedMap.get(compositeId).__Appearance_Count += 1;
            }

            const uniqueRecords = Array.from(consolidatedMap.values());
            
            // 2. Cross-File Matching Pass
            // Group records by the primary matching key (ID column value)
            const matchKeyMap = new Map();
            for (const record of uniqueRecords) {
                const key = record.__Match_Key;
                if (!matchKeyMap.has(key)) {
                    matchKeyMap.set(key, { a: [], b: [] });
                }
                
                const isA = record.__Source_File === fileDataA.name;
                const mapKey = isA ? 'a' : 'b';
                matchKeyMap.get(key)[mapKey].push(record);
            }

            // 3. Determine Matched/Unmatched Status (Based on key appearance in BOTH files)
            const matchedA = [];
            const unmatchedA = [];
            const matchedB = [];
            const unmatchedB = [];

            for (const [key, group] of matchKeyMap.entries()) {
                const isMatched = group.a.length > 0 && group.b.length > 0;

                if (isMatched) {
                    matchedA.push(...group.a);
                    matchedB.push(...group.b);
                } else {
                    unmatchedA.push(...group.a);
                    unmatchedB.push(...group.b);
                }
            }

            // 4. Calculate New Summary Metrics for the Summary.xlsx file
            
            const calculateMetrics = (data, isA) => {
                const amountCol = isA ? fileDataA.amountCol : fileDataB.amountCol;
                const totalCount = data.length;
                const totalAmount = data.reduce((sum, item) => sum + (parseFloat(item[amountCol]) || 0), 0);
                return { totalCount, totalAmount };
            };
            
            // Helper to sum counts and amounts from a list of records
            const sumRecordsMetrics = (records, isA) => {
                const amountCol = isA ? fileDataA.amountCol : fileDataB.amountCol;
                const count = records.length;
                const amount = records.reduce((sum, item) => sum + (parseFloat(item[amountCol]) || 0), 0);
                return { count, amount };
            };

            const allA = uniqueRecords.filter(r => r.__Source_File === fileDataA.name);
            const allB = uniqueRecords.filter(r => r.__Source_File === fileDataB.name);
            
            const totalMetricsA = sumRecordsMetrics(allA, true);
            const matchedMetricsA = sumRecordsMetrics(matchedA, true);
            const unmatchedMetricsA = sumRecordsMetrics(unmatchedA, true);

            const totalMetricsB = sumRecordsMetrics(allB, false);
            const matchedMetricsB = sumRecordsMetrics(matchedB, false);
            const unmatchedMetricsB = sumRecordsMetrics(unmatchedB, false);


            setResults({
                matchedA,
                unmatchedA,
                matchedB,
                unmatchedB,
                // Summary metrics for display/Summary.xlsx
                summaryMetricsA: {
                    totalCount: totalMetricsA.count,
                    totalAmount: totalMetricsA.amount,
                    matchedCount: matchedMetricsA.count,
                    matchedAmount: matchedMetricsA.amount,
                    unmatchedCount: unmatchedMetricsA.count,
                    unmatchedAmount: unmatchedMetricsA.amount,
                },
                summaryMetricsB: {
                    totalCount: totalMetricsB.count,
                    totalAmount: totalMetricsB.amount,
                    matchedCount: matchedMetricsB.count,
                    matchedAmount: matchedMetricsB.amount,
                    unmatchedCount: unmatchedMetricsB.count,
                    unmatchedAmount: unmatchedMetricsB.amount,
                },
            });
            setStep(3); // Move to results step

            setLoading(false);
        }, [fileDataA, fileDataB]);


        // Helper function to filter report data based on user selection
        const getFilteredReportData = (data, selectedHeaders, isA) => {
            const originalHeaders = isA ? fileDataA.headers : fileDataB.headers;
            const requiredHeaders = [...TRACE_COLS, ...selectedHeaders.filter(h => originalHeaders.includes(h))];

            return data.map(row => {
                const newRow = {};
                for (const header of requiredHeaders) {
                    newRow[header] = row[header] !== undefined ? row[header] : '';
                }
                return newRow;
            });
        };

        // Function to create the Summary Report worksheet
        const createSummaryWorksheet = (metricsA, metricsB) => {
            const headers = ["Category", "Status", "Count", "Amount"];
            
            const formatAmount = (num) => typeof num === 'number' ? num.toFixed(2) : '0.00';

            const data = [
                // Consolidated A
                ["A", "Total Consolidated", metricsA.totalCount, formatAmount(metricsA.totalAmount)],
                ["A", "Matched", metricsA.matchedCount, formatAmount(metricsA.matchedAmount)],
                ["A", "Unmatched", metricsA.unmatchedCount, formatAmount(metricsA.unmatchedAmount)],
                // Consolidated B
                ["B", "Total Consolidated", metricsB.totalCount, formatAmount(metricsB.totalAmount)],
                ["B", "Matched", metricsB.matchedCount, formatAmount(metricsB.matchedAmount)],
                ["B", "Unmatched", metricsB.unmatchedCount, formatAmount(metricsB.unmatchedAmount)],
            ];

            return [headers, ...data];
        };

        // New download function for individual files
        const downloadSelectedReports = useCallback(() => {
            if (!results) return;

            setLoading(true);
            const { summaryMetricsA, summaryMetricsB, matchedA, unmatchedA, matchedB, unmatchedB } = results;

            const reportsToGenerate = selectedDownloads.map(id => 
                downloadOptions.find(opt => opt.id === id)
            ).filter(Boolean); // Filter out nulls

            reportsToGenerate.forEach(report => {
                let reportData = [];
                let headers = [];
                let isSummary = false;

                // 1. Prepare Data based on Report Type
                switch (report.id) {
                    case 'Summary':
                        reportData = createSummaryWorksheet(summaryMetricsA, summaryMetricsB);
                        isSummary = true;
                        break;
                    case 'A_Matched':
                        reportData = getFilteredReportData(matchedA, selectedColsA, true);
                        break;
                    case 'A_Unmatched':
                        reportData = getFilteredReportData(unmatchedA, selectedColsA, true);
                        break;
                    case 'B_Matched':
                        reportData = getFilteredReportData(matchedB, selectedColsB, false);
                        break;
                    case 'B_Unmatched':
                        reportData = getFilteredReportData(unmatchedB, selectedColsB, false);
                        break;
                    default:
                        return; // Skip unknown reports
                }

                // 2. Generate and Download File
                const ws = isSummary 
                    ? XLSX.utils.aoa_to_sheet(reportData) // Array of Arrays for Summary
                    : XLSX.utils.json_to_sheet(reportData); // Array of Objects for Detailed

                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, report.id);
                XLSX.writeFile(wb, report.fileName);
            });

            setLoading(false);
            // Optionally, clear selection after download, but keeping it allows re-downloading
            // setSelectedDownloads([]); 
        }, [results, selectedDownloads, selectedColsA, selectedColsB, downloadOptions, fileDataA, fileDataB]);


        // Handlers for column and download selection
        const handleColumnChange = (header, category) => {
            const setter = category === 'A' ? setSelectedColsA : setSelectedColsB;
            setter(prev => 
                prev.includes(header)
                    ? prev.filter(col => col !== header)
                    : [...prev, header]
            );
        };

        const handleDownloadToggle = (id) => {
            setSelectedDownloads(prev => 
                prev.includes(id)
                    ? prev.filter(d => d !== id)
                    : [...prev, id]
            );
        };


        // Determine if we are ready to move from Step 2 (Configuration) to Reconciliation
        const isConfigReady = fileDataA.idCol && fileDataA.amountCol && fileDataB.idCol && fileDataB.amountCol;


        // Render Helpers for Upload Step (Step 1)
        const UploadCard = ({ fileData, setFileData, isA, handleFileUpload }) => {
            const category = isA ? 'A' : 'B';
            return (
                <div className="flex flex-col items-center bg-white p-6 rounded-xl shadow-lg border border-indigo-200/50 transition duration-300 hover:shadow-xl">
                    <FileSpreadsheet size={48} className="text-indigo-500 mb-4" />
                    <h3 className="text-xl font-bold mb-2 text-gray-800">Category {category} File</h3>
                    <p className="text-sm text-gray-500 mb-4">{isA ? 'Your Source Data' : 'Your Target Data'}</p>
                    {fileData.name ? (
                        <>
                            <p className="text-center font-semibold text-indigo-700 break-all mb-4">{fileData.name}</p>
                            <span className="text-xs text-green-600 bg-green-100 px-3 py-1 rounded-full">Loaded: {fileData.data.length} records</span>
                        </>
                    ) : (
                        <label className="cursor-pointer bg-indigo-500 text-white px-5 py-2 rounded-lg font-semibold hover:bg-indigo-600 transition shadow-md">
                            <Upload size={18} className="inline mr-2" />
                            Upload File {category}
                            <input
                                type="file"
                                accept=".xlsx,.xls,.csv"
                                onChange={(e) => handleFileUpload(e, setFileData, isA)}
                                className="hidden"
                            />
                        </label>
                    )}
                </div>
            );
        };

        // Render Helpers for Column Configuration (Step 2)
        const ColumnSelect = ({ fileData, setFileData, label, columnType, isA }) => {
            const setter = isA ? setSelectedColsA : setSelectedColsB;
            const value = isA ? fileData.idCol : fileData.amountCol; // Placeholder, need actual usage
            
            return (
                <div className="flex flex-col">
                    <label className="text-sm font-medium text-gray-700 mb-1">{label} ({isA ? 'A' : 'B'})</label>
                    <select
                        className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md shadow-sm"
                        value={fileData[columnType] || ''}
                        onChange={(e) => setFileData(prev => ({ ...prev, [columnType]: e.target.value }))}
                    >
                        <option value="" disabled>Select a column</option>
                        {fileData.headers.map(header => (
                            <option key={header} value={header}>{header}</option>
                        ))}
                    </select>
                </div>
            );
        };


        // --- MAIN RENDER ---
        return (
            <div className="p-4 sm:p-8 max-w-7xl mx-auto">
                <header className="text-center mb-8">
                    <h1 className="text-4xl font-extrabold text-indigo-700">Advanced Reconciliation Tool</h1>
                    <p className="text-gray-500 mt-2">Match transactions based on ID and Amount across two files.</p>
                </header>

                <div className="relative bg-white p-6 sm:p-10 rounded-2xl shadow-2xl border border-indigo-100">
                    
                    {/* Loading Overlay */}
                    {loading && (
                        <div className="loading-overlay">
                            <div className="flex flex-col items-center">
                                <svg className="animate-spin h-8 w-8 text-indigo-500 mb-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                                <p className="text-indigo-600 font-medium">Processing...</p>
                            </div>
                        </div>
                    )}

                    {/* Error Message */}
                    {error && (
                        <div className="mb-4 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg">
                            <p className="font-semibold">Error:</p>
                            <p>{error}</p>
                        </div>
                    )}

                    {/* STEP 1: UPLOAD */}
                    {step === 1 && (
                        <div>
                            <h2 className="text-2xl font-semibold text-gray-800 mb-6 border-b pb-3">1. Upload Files</h2>
                            <div className="grid md:grid-cols-2 gap-8">
                                <UploadCard fileData={fileDataA} setFileData={setFileDataA} isA={true} handleFileUpload={handleFileUpload} />
                                <UploadCard fileData={fileDataB} setFileData={setFileDataB} isA={false} handleFileUpload={handleFileUpload} />
                            </div>
                            <div className="mt-8 p-4 bg-indigo-50 border border-indigo-200 rounded-lg">
                                <p className="text-sm text-indigo-800 flex items-start">
                                    <Info size={18} className="mr-2 mt-0.5 flex-shrink-0 text-indigo-600" />
                                    <span>
                                        Files must be in Excel (.xlsx, .xls) or CSV format. Once both files are uploaded, you can proceed to the configuration step.
                                    </span>
                                </p>
                            </div>
                        </div>
                    )}

                    {/* STEP 2: CONFIGURE & SELECT COLUMNS */}
                    {step === 2 && (
                        <div>
                            <h2 className="text-2xl font-semibold text-gray-800 mb-6 border-b pb-3">2. Configure Columns</h2>
                            
                            <div className="grid md:grid-cols-2 gap-6 mb-8">
                                {/* File A Configuration */}
                                <div className="p-6 bg-gray-50 rounded-lg border border-gray-200">
                                    <h3 className="text-lg font-bold text-indigo-700 mb-4">File A: {fileDataA.name}</h3>
                                    <div className="space-y-4">
                                        <ColumnSelect 
                                            fileData={fileDataA} 
                                            setFileData={setFileDataA} 
                                            label="Matching ID Column" 
                                            columnType="idCol" 
                                            isA={true}
                                        />
                                        <ColumnSelect 
                                            fileData={fileDataA} 
                                            setFileData={setFileDataA} 
                                            label="Amount Column" 
                                            columnType="amountCol" 
                                            isA={true}
                                        />
                                    </div>
                                    <ColumnSelector
                                        category="Category A"
                                        headers={fileDataA.headers}
                                        selectedCols={selectedColsA}
                                        setSelectedCols={setSelectedColsA}
                                    />
                                </div>
                                
                                {/* File B Configuration */}
                                <div className="p-6 bg-gray-50 rounded-lg border border-gray-200">
                                    <h3 className="text-lg font-bold text-indigo-700 mb-4">File B: {fileDataB.name}</h3>
                                    <div className="space-y-4">
                                        <ColumnSelect 
                                            fileData={fileDataB} 
                                            setFileData={setFileDataB} 
                                            label="Matching ID Column" 
                                            columnType="idCol" 
                                            isA={false}
                                        />
                                        <ColumnSelect 
                                            fileData={fileDataB} 
                                            setFileData={setFileDataB} 
                                            label="Amount Column" 
                                            columnType="amountCol" 
                                            isA={false}
                                        />
                                    </div>
                                    <ColumnSelector
                                        category="Category B"
                                        headers={fileDataB.headers}
                                        selectedCols={selectedColsB}
                                        setSelectedCols={setSelectedColsB}
                                    />
                                </div>
                            </div>

                            <div className="text-center pt-4 border-t">
                                <button
                                    onClick={performReconciliation}
                                    disabled={!isConfigReady || loading}
                                    className={`px-8 py-3 rounded-lg font-bold text-white transition duration-200 ${isConfigReady && !loading ? 'bg-indigo-600 hover:bg-indigo-700 shadow-lg' : 'bg-indigo-400 cursor-not-allowed'}`}
                                >
                                    Run Reconciliation
                                </button>
                            </div>
                        </div>
                    )}

                    {/* STEP 3: RESULTS & DOWNLOAD */}
                    {step === 3 && results && (
                        <div>
                            <h2 className="text-2xl font-semibold text-gray-800 mb-6 border-b pb-3 flex items-center">
                                <CheckCheck size={24} className="text-green-500 mr-2" />
                                3. Reconciliation Complete
                            </h2>

                            {/* Structured Summary Tables */}
                            <div className="bg-gray-50 rounded-xl p-6 shadow-inner mb-8">
                                <h3 className="font-bold text-xl mb-4 text-gray-800">Reconciliation Summary (Source for Summary.xlsx)</h3>
                                <div className="grid md:grid-cols-2 gap-6">
                                    {/* Category A Summary */}
                                    <SummaryTable metrics={results.summaryMetricsA} category="Category A" />
                                    
                                    {/* Category B Summary */}
                                    <SummaryTable metrics={results.summaryMetricsB} category="Category B" />
                                </div>
                            </div>
                            
                            {/* Download Options */}
                            <div className="bg-white p-6 rounded-xl shadow-md border border-gray-200">
                                <h3 className="font-bold text-xl mb-4 text-gray-800">Select Reports for Download</h3>
                                
                                <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-5 gap-4 border-b pb-4 mb-4">
                                    {downloadOptions.map((option) => (
                                        <label key={option.id} className="flex items-center space-x-2 p-2 bg-gray-50 rounded-lg cursor-pointer hover:bg-indigo-50 transition">
                                            <input
                                                type="checkbox"
                                                checked={selectedDownloads.includes(option.id)}
                                                onChange={() => handleDownloadToggle(option.id)}
                                                className="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                                            />
                                            <span className="text-sm font-medium text-gray-700">{option.name}</span>
                                        </label>
                                    ))}
                                </div>

                                <div className="text-center">
                                    <button
                                        onClick={downloadSelectedReports}
                                        disabled={selectedDownloads.length === 0 || loading}
                                        className={`px-8 py-4 rounded-xl font-bold text-white transition duration-200 text-lg shadow-xl flex items-center justify-center mx-auto ${selectedDownloads.length > 0 && !loading ? 'bg-green-600 hover:bg-green-700' : 'bg-green-400 cursor-not-allowed'}`}
                                    >
                                        <Download size={24} className="mr-2" />
                                        Download ({selectedDownloads.length}) Report{selectedDownloads.length !== 1 ? 's' : ''}
                                    </button>
                                </div>
                            </div>

                            <div className="mt-8 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                                <p className="text-sm text-blue-800 flex items-start">
                                    <Info size={18} className="mr-2 mt-0.5 flex-shrink-0 text-blue-600" />
                                    <span>
                                        **Traceability Note:** All generated detailed reports include the **`__Composite_ID`** (the match key, serialized), **`__Source_File`**, **`__Original_Row_Index`**, and **`__Appearance_Count`** columns for traceability. Detailed reports contain **only** the columns you selected in Step 2, plus these mandatory trace columns.
                                    </span>
                                </p>
                            </div>

                            <div className="text-center pt-8">
                                <button 
                                    onClick={() => { setStep(1); setResults(null); setFileDataA(initialState); setFileDataB(initialState); setSelectedColsA([]); setSelectedColsB([]); setSelectedDownloads(['Summary']); }} 
                                    className="px-6 py-3 border border-gray-300 text-gray-700 font-semibold rounded-lg hover:bg-gray-100 transition duration-200"
                                >
                                    Start New Reconciliation
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            </div>
        );
    };

    // Render the React application
    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    root.render(<ReconciliationApp />);

    </script>
</body>
</html>
