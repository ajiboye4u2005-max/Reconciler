<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Reconciliation Tool (Layered ID Extraction)</title>
    <!-- Load React and ReactDOM from CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Load Babel for JSX transpilation in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load SheetJS/XLSX for Excel file handling -->
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
</head>
<body class="bg-gray-50 min-h-screen font-sans">
    <div id="root"></div>

    <script type="text/babel">
    // Destructure hooks from the global React object for easy access (FIX: addresses ReferenceError: useState is not defined)
    const { useState, useEffect, useCallback, useMemo } = React;
    
    // --- ICON PLACEHOLDERS (Replacing lucide-react imports for single-file HTML) ---
    const IconWrapper = ({ children, size = 20, className = '', color = 'currentColor' }) => (
        <span className={className} style={{ width: size, height: size, display: 'inline-flex', alignItems: 'center', justifyContent: 'center', color: color }}>{children}</span>
    );
    const Upload = (props) => <IconWrapper {...props}><span role="img" aria-label="Upload" className="font-bold">â¤’</span></IconWrapper>;
    const FileSpreadsheet = (props) => <IconWrapper {...props}><span role="img" aria-label="Spreadsheet" className="font-bold">ðŸ“‹</span></IconWrapper>;
    const FileDown = (props) => <IconWrapper {...props}><span role="img" aria-label="Download" className="font-bold">â†“</span></IconWrapper>;
    const Info = (props) => <IconWrapper {...props}><span role="img" aria-label="Info" className="font-bold">â“˜</span></IconWrapper>;
    const Check = (props) => <IconWrapper {...props}><span role="img" aria-label="Check" className="font-bold">âœ“</span></IconWrapper>;
    const X = (props) => <IconWrapper {...props}><span role="img" aria-label="Error" className="font-bold">âœ•</span></IconWrapper>;
    
    // Constants
    const CATEGORIES = {
        A: 'Category A',
        B: 'Category B',
    };

    // Helper to format numbers as currency
    const formatCurrency = (value) => {
        if (value === null || value === undefined) return 'N/A';
        return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD',
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        }).format(value);
    };

    // Helper to format numbers as integers with separators
    const formatNumber = (value) => {
        if (value === null || value === undefined) return 'N/A';
        return new Intl.NumberFormat('en-US').format(value);
    };

    // --- Core Logic ---

    // 1. Data Cleaning and Preparation
    const cleanCell = (value) => {
        if (typeof value === 'string') {
            // Remove all non-alphanumeric characters except spaces and hyphens, and normalize case
            return value.trim().toUpperCase().replace(/[^A-Z0-9\s-]/g, '');
        }
        return String(value).trim().toUpperCase();
    };

    const extractCompositeId = (narration) => {
        // Look for common ID patterns in the narration string
        // This is a simplified regex logic for demonstration
        const refMatch = narration.match(/REF[:\s]([A-Z0-9]{15,})/); // e.g., REF:12345678901234567890
        if (refMatch) return refMatch[1];
        
        const txnMatch = narration.match(/TXN[:\s]([A-Z0-9]{15,})/); // e.g., TXN:12345678901234567890
        if (txnMatch) return txnMatch[1];

        // Fallback: If no clear ID is found, use a hash or placeholder based on the whole string
        return narration.substring(0, 50); // A non-unique fallback is acceptable for "unidentified" items
    };

    // 2. Reconciliation Logic (The heavy lifting)
    const calculateReconciliation = (dataA, dataB) => {
        if (!dataA.length || !dataB.length) {
            return {
                matched: [], unmatchedA: [], unmatchedB: [], duplicatedA: new Map(), duplicatedB: new Map(),
                summaryMetricsA: {}, summaryMetricsB: {},
            };
        }

        const compositeDataA = dataA.map((row, index) => {
            const narration = String(row.Narration || '');
            const id = extractCompositeId(narration);
            return {
                ...row,
                Composite_ID: id,
                Amount: (row.Credit || 0) - (row.Debit || 0), // Calculate net amount
                __Source_File: row.__Source_File, // Retain for traceability
                __Original_Row_Index: index + 2, // 1 for header, 1 for 0-indexing
                __UniqueRef: row.UniqueRef,
            };
        });

        const compositeDataB = dataB.map((row, index) => {
            const narration = String(row.Narration || '');
            const id = extractCompositeId(narration);
            return {
                ...row,
                Composite_ID: id,
                Amount: (row.Credit || 0) - (row.Debit || 0), // Calculate net amount
                __Source_File: row.__Source_File,
                __Original_Row_Index: index + 2,
                __UniqueRef: row.UniqueRef,
            };
        });

        // --- Core Reconciliation Maps ---
        const mapA = new Map(); // Key: Composite_ID, Value: Array of records
        const mapB = new Map(); 

        const populateMap = (data, map) => {
            data.forEach(item => {
                const key = item.Composite_ID;
                if (map.has(key)) {
                    map.get(key).push(item);
                } else {
                    map.set(key, [item]);
                }
            });
        };

        populateMap(compositeDataA, mapA);
        populateMap(compositeDataB, mapB);

        // --- Results Containers ---
        const matched = [];
        const unmatchedA = [];
        const unmatchedB = [];
        const duplicatedA = new Map(); // Key: Composite_ID, Value: Array of records (where count > 1)
        const duplicatedB = new Map();

        // --- 1. Identify Duplicates and prepare for matching (Unique IDs only) ---

        const getUniqueIdRecords = (map, duplicatedMap) => {
            const uniqueRecords = new Map(); // Key: Composite_ID, Value: Single record
            map.forEach((records, id) => {
                if (records.length > 1) {
                    duplicatedMap.set(id, records.map((r, i) => ({ ...r, Appearance_Count: i + 1 })));
                } else {
                    uniqueRecords.set(id, records[0]);
                }
            });
            return uniqueRecords;
        };

        const uniqueMapA = getUniqueIdRecords(mapA, duplicatedA);
        const uniqueMapB = getUniqueIdRecords(mapB, duplicatedB);

        // --- 2. Perform Matching (Only on unique IDs) ---

        // Find matches and remaining unmatched in A
        uniqueMapA.forEach((recordA, id) => {
            if (uniqueMapB.has(id)) {
                const recordB = uniqueMapB.get(id);
                
                // Add to matched list
                matched.push({
                    ...recordA, 
                    ...recordB,
                    Composite_ID: id, // Ensure ID is present in the final object
                });
                // Remove from B's unique map to mark as processed
                uniqueMapB.delete(id);
            } else {
                // Not found in B
                unmatchedA.push({ ...recordA, Appearance_Count: 1 });
            }
        });

        // The remaining records in uniqueMapB are unmatched
        uniqueMapB.forEach((recordB, id) => {
            unmatchedB.push({ ...recordB, Appearance_Count: 1 });
        });

        // --- 3. Calculate Summary Metrics ---
        
        // Helper to calculate summary metrics
        const calculateMetrics = (data, duplicatedMap) => {
            const totalDistinctCount = data.length;
            const totalDistinctAmount = data.reduce((sum, item) => sum + (item.Amount || 0), 0);

            let totalDuplicatedUniqueIDs = 0;
            let totalDuplicatedAmount = 0;
            let totalDuplicatedItemCount = 0;

            duplicatedMap.forEach(records => {
                totalDuplicatedUniqueIDs++;
                totalDuplicatedItemCount += records.length;
                totalDuplicatedAmount += records.reduce((sum, item) => sum + (item.Amount || 0), 0);
            });
            
            return {
                totalDistinctCount,
                totalDistinctAmount,
                totalDuplicatedUniqueIDs,
                totalDuplicatedAmount,
                totalDuplicatedItemCount,
            };
        };

        const summaryA = {
            ...calculateMetrics([...unmatchedA, ...matched.map(m => ({ Amount: m.Amount }))], duplicatedA),
            matchedCount: matched.length,
            matchedAmount: matched.reduce((sum, m) => sum + (m.Amount || 0), 0),
            unmatchedCount: unmatchedA.length,
            unmatchedAmount: unmatchedA.reduce((sum, u) => sum + (u.Amount || 0), 0),
        };
        
        const summaryB = {
            ...calculateMetrics([...unmatchedB, ...matched.map(m => ({ Amount: m.Amount }))], duplicatedB),
            matchedCount: matched.length, // Matched count is the same for both
            matchedAmount: matched.reduce((sum, m) => sum + (m.Amount || 0), 0),
            unmatchedCount: unmatchedB.length,
            unmatchedAmount: unmatchedB.reduce((sum, u) => sum + (u.Amount || 0), 0),
        };

        // Combine matched data for download
        const matchedOutputA = matched.map(m => ({ ...m, Appearance_Count: 1, Composite_ID: m.Composite_ID, __Source_File: m.__Source_File, __Original_Row_Index: m.__Original_Row_Index }));
        const matchedOutputB = matched.map(m => ({ ...m, Appearance_Count: 1, Composite_ID: m.Composite_ID, __Source_File: m.__Source_File, __Original_Row_Index: m.__Original_Row_Index }));


        return {
            matchedA: matchedOutputA,
            matchedB: matchedOutputB,
            unmatchedA: unmatchedA,
            unmatchedB: unmatchedB,
            duplicatedA: Array.from(duplicatedA.values()).flat(),
            duplicatedB: Array.from(duplicatedB.values()).flat(),
            summaryMetricsA: summaryA,
            summaryMetricsB: summaryB,
        };
    };

    // 3. File Processing
    const processFile = (file, category) => {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    // Read data, ensuring all values are treated as text/strings to preserve unique IDs
                    const json = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: null, raw: false });
                    
                    if (json.length < 2) {
                        return reject(new Error("File is empty or contains only headers."));
                    }

                    const headers = json[0].map(h => h ? h.trim() : '');
                    const requiredCols = ['Narration', 'Debit', 'Credit', 'UniqueRef']; // Essential columns
                    if (!requiredCols.every(col => headers.includes(col))) {
                        return reject(new Error(`Missing required columns: ${requiredCols.join(', ')}. Found: ${headers.join(', ')}`));
                    }

                    const dataRows = json.slice(1).map(row => {
                        const rowData = {};
                        headers.forEach((header, index) => {
                            let value = row[index];
                            if (header === 'Debit' || header === 'Credit') {
                                // Convert numeric values, handle nulls gracefully
                                rowData[header] = typeof value === 'string' ? parseFloat(value.replace(/,/g, '')) : (value || 0);
                            } else {
                                // Keep all other fields as string
                                rowData[header] = String(value || '');
                            }
                        });
                        rowData.__Source_File = file.name;
                        return rowData;
                    });
                    
                    resolve(dataRows);
                } catch (error) {
                    reject(new Error(`Error processing file ${file.name}: ${error.message}`));
                }
            };
            reader.onerror = (error) => reject(new Error(`Error reading file ${file.name}: ${error.message}`));
            reader.readAsArrayBuffer(file);
        });
    };
    
    // 4. Download Logic (Updated for selective and complex summary sheet)
    const cleanDataForDownload = (data, type) => {
        if (!data || data.length === 0) return [];
        
        // Define the desired order and inclusion for all output sheets
        const baseHeaders = Object.keys(data[0]);
        
        const traceColumns = ['Composite_ID', '__Source_File', '__Original_Row_Index', 'Appearance_Count'];
        const amountColumns = ['Amount', 'Debit', 'Credit'];
        const keyColumns = ['UniqueRef', 'Account No', 'Date', 'Narration'];

        const desiredOrder = [...traceColumns, ...keyColumns, ...amountColumns].filter(col => baseHeaders.includes(col) || col === 'Appearance_Count');
        
        const headerMap = {
            'Composite_ID': 'Composite_ID',
            '__Source_File': 'Source_File',
            '__Original_Row_Index': 'Original_Row_Index',
            'Appearance_Count': 'Appearance_Count',
            'Amount': 'Net_Amount (Credit - Debit)',
        };

        // Create clean, ordered data array
        return data.map(row => {
            const newRow = {};
            desiredOrder.forEach(col => {
                newRow[headerMap[col] || col] = row[col] !== undefined ? row[col] : (col === 'Appearance_Count' ? 1 : '');
            });
            return newRow;
        });
    };

    const downloadReport = async (results, selectedDownloads) => {
        if (selectedDownloads.length === 0) {
            console.error("No reports selected for download.");
            return;
        }

        const wb = XLSX.utils.book_new();

        const allSheets = [
            { id: 'matchedA', name: 'A_Matched', data: cleanDataForDownload(results.matchedA, 'Matched') },
            { id: 'unmatchedA', name: 'A_Unmatched', data: cleanDataForDownload(results.unmatchedA, 'Unmatched') },
            { id: 'duplicatedA', name: 'A_Duplicated', data: cleanDataForDownload(results.duplicatedA, 'Duplicated') },
            { id: 'matchedB', name: 'B_Matched', data: cleanDataForDownload(results.matchedB, 'Matched') },
            { id: 'unmatchedB', name: 'B_Unmatched', data: cleanDataForDownload(results.unmatchedB, 'Unmatched') },
            { id: 'duplicatedB', name: 'B_Duplicated', data: cleanDataForDownload(results.duplicatedB, 'Duplicated') },
        ];

        // Add selected data sheets
        allSheets.filter(sheet => selectedDownloads.includes(sheet.id)).forEach(sheet => {
            if (sheet.data.length > 0) {
                const ws = XLSX.utils.json_to_sheet(sheet.data);
                XLSX.utils.book_append_sheet(wb, ws, sheet.name);
            } else {
                // Add empty sheet if selected but no data
                const ws = XLSX.utils.aoa_to_sheet([['No Data']]);
                XLSX.utils.book_append_sheet(wb, ws, sheet.name);
            }
        });

        // ----------------------------------------------------
        // Generate the Complex Summary Sheet if selected
        // ----------------------------------------------------
        if (selectedDownloads.includes('summary')) {
            const smA = results.summaryMetricsA;
            const smB = results.summaryMetricsB;

            // Calculate Totals required for the final summary lines
            const totalMatchedCount = smA.matchedCount; // A and B matched counts are the same by definition
            const totalMatchedAmount = smA.matchedAmount;

            const totalUnmatchedCount = smA.unmatchedCount + smB.unmatchedCount;
            const totalUnmatchedAmount = smA.unmatchedAmount + smB.unmatchedAmount;

            const grandTotalDistinctCountA = smA.totalDistinctCount;
            const grandTotalDistinctAmountA = smA.totalDistinctAmount;
            const grandTotalDistinctCountB = smB.totalDistinctCount;
            const grandTotalDistinctAmountB = smB.totalDistinctAmount;

            const totalDuplicatedUniqueIDsA = smA.totalDuplicatedUniqueIDs;
            const totalDuplicatedAmountA = smA.totalDuplicatedAmount;
            const totalDuplicatedUniqueIDsB = smB.totalDuplicatedUniqueIDs;
            const totalDuplicatedAmountB = smB.totalDuplicatedAmount;
            
            // Total of the 2 (Distinct + Duplicated unique IDs)
            const overallTotalCountA = grandTotalDistinctCountA + totalDuplicatedUniqueIDsA;
            const overallTotalAmountA = grandTotalDistinctAmountA + totalDuplicatedAmountA;
            const overallTotalCountB = grandTotalDistinctCountB + totalDuplicatedUniqueIDsB;
            const overallTotalAmountB = grandTotalDistinctAmountB + totalDuplicatedAmountB;

            // Grand Total (A + B)
            const overallGrandTotalCount = overallTotalCountA + overallTotalCountB;
            const overallGrandTotalAmount = overallTotalAmountA + overallTotalAmountB;

            // Total Matched + Unmatched (A + B)
            const matchedUnmatchedTotalCount = totalMatchedCount + totalUnmatchedCount;
            const matchedUnmatchedTotalAmount = totalMatchedAmount + totalUnmatchedAmount;

            // Difference
            const differenceCount = overallGrandTotalCount - matchedUnmatchedTotalCount;
            const differenceAmount = overallGrandTotalAmount - matchedUnmatchedTotalAmount;


            const summaryData = [
                ['SUMMARY: A vs B Reconciliation Metrics', null, null, null, null],
                ['Metric Description', 'Category A (Count)', 'Category A (Amount)', 'Category B (Count)', 'Category B (Amount)'],
                // Distinct Unique ID count and amount
                ['Total Distinct Unique IDs (Matches + Unmatched)', 
                    grandTotalDistinctCountA, grandTotalDistinctAmountA, 
                    grandTotalDistinctCountB, grandTotalDistinctAmountB
                ],
                // Total Duplicated unique ID count and amount
                ['Total Duplicated Unique IDs', 
                    totalDuplicatedUniqueIDsA, totalDuplicatedAmountA, 
                    totalDuplicatedUniqueIDsB, totalDuplicatedAmountB
                ],
                // Total of the 2 (Distinct + Duplicated)
                ['GRAND TOTAL OF UNIQUE IDs (Distinct + Duplicated IDs)', 
                    overallTotalCountA, overallTotalAmountA, 
                    overallTotalCountB, overallTotalAmountB
                ],
                // Blank row for separation
                [], 
                // Total Matched and Unmatched (combined A & B)
                ['--- Combined Reconciliation Metrics (A & B) ---', null, null, null, null],
                ['Total Matched Unique IDs (A vs B)', totalMatchedCount, totalMatchedAmount, null, null],
                ['Total Unmatched Unique IDs (A + B)', totalUnmatchedCount, totalUnmatchedAmount, null, null],
                ['TOTAL MATCHED & UNMATCHED ITEMS', matchedUnmatchedTotalCount, matchedUnmatchedTotalAmount, null, null],
                // Blank row for separation
                [], 
                // Deduct the 2 totals
                ['TOTAL DIFFERENCE (Grand Total Unique IDs - Matched & Unmatched Total)', differenceCount, differenceAmount, null, null],
            ];

            const ws = XLSX.utils.aoa_to_sheet(summaryData);

            // Apply formatting for currency/number columns (Col B, C, D, E)
            const range = XLSX.utils.decode_range(ws['!ref']);
            for (let R = range.s.r + 2; R <= range.e.r; ++R) { // Start from row 3 (index 2)
                ['B', 'C', 'D', 'E'].forEach((col, idx) => {
                    const cellRef = col + (R + 1);
                    const cell = ws[cellRef];
                    if (cell && typeof cell.v === 'number') {
                        // Custom format to display as number or currency
                        if (idx % 2 === 0) { // Count columns (B, D)
                            cell.z = '#,##0';
                        } else { // Amount columns (C, E)
                            cell.z = '$#,##0.00';
                        }
                    }
                });
            }

            // Set styles for headers and titles (not directly supported by sheetjs, but AOAs can be used to structure)
            // A1: Title styling
            if (ws['A1']) ws['A1'].s = { font: { sz: 14, bold: true }, fill: { fgColor: { rgb: "FFFFE0B2" } } };
            // A2-E2: Header styling
            if (ws['A2']) ws['A2'].s = { font: { bold: true }, fill: { fgColor: { rgb: "FFD9E1F2" } } };
            
            XLSX.utils.book_append_sheet(wb, ws, "Summary A & B Side By Side");
        }

        XLSX.writeFile(wb, "Reconciliation_Report_" + Date.now() + ".xlsx");
    };

    // --- Components ---

    const SimpleSummaryDisplay = ({ results }) => {
        const smA = results.summaryMetricsA;
        const smB = results.summaryMetricsB;

        const tableData = [
            { 
                label: "Matched Unique IDs", 
                countA: smA.matchedCount, 
                amountA: smA.matchedAmount,
                countB: smB.matchedCount,
                amountB: smB.matchedAmount,
                isPrimary: true
            },
            { 
                label: "Unmatched Unique IDs", 
                countA: smA.unmatchedCount, 
                amountA: smA.unmatchedAmount,
                countB: smB.unmatchedCount,
                amountB: smB.unmatchedAmount,
                isPrimary: true
            },
            { 
                label: "Total Distinct Unique IDs", 
                countA: smA.totalDistinctCount, 
                amountA: smA.totalDistinctAmount,
                countB: smB.totalDistinctCount,
                amountB: smB.totalDistinctAmount,
                isPrimary: false
            },
        ];

        return (
            <div className="bg-white shadow-xl rounded-xl overflow-hidden border border-gray-200">
                <div className="p-4 bg-gray-50 border-b border-gray-200">
                    <h3 className="text-xl font-extrabold text-gray-800">Reconciliation Snapshot</h3>
                    <p className="text-sm text-gray-500">Matched, Unmatched, and Total Distinct IDs (Excluding Duplicates)</p>
                </div>
                <div className="overflow-x-auto">
                    <table className="min-w-full divide-y divide-gray-200">
                        <thead className="bg-gray-100">
                            <tr>
                                <th className="px-4 py-3 text-left text-xs font-semibold text-gray-600 uppercase tracking-wider">Metric</th>
                                <th className="px-4 py-3 text-right text-xs font-semibold text-gray-600 uppercase tracking-wider">Count (A)</th>
                                <th className="px-4 py-3 text-right text-xs font-semibold text-gray-600 uppercase tracking-wider">Amount (A)</th>
                                <th className="px-4 py-3 text-right text-xs font-semibold text-gray-600 uppercase tracking-wider">Count (B)</th>
                                <th className="px-4 py-3 text-right text-xs font-semibold text-gray-600 uppercase tracking-wider">Amount (B)</th>
                            </tr>
                        </thead>
                        <tbody className="bg-white divide-y divide-gray-200">
                            {tableData.map((row, index) => (
                                <tr key={index} className={row.isPrimary ? 'bg-white hover:bg-yellow-50/50' : 'bg-gray-50 font-bold hover:bg-gray-100'}>
                                    <td className="px-4 py-3 text-sm text-gray-900 font-medium">{row.label}</td>
                                    <td className="px-4 py-3 text-sm text-gray-700 text-right">{formatNumber(row.countA)}</td>
                                    <td className="px-4 py-3 text-sm text-green-700 font-mono text-right">{formatCurrency(row.amountA)}</td>
                                    <td className="px-4 py-3 text-sm text-gray-700 text-right">{formatNumber(row.countB)}</td>
                                    <td className="px-4 py-3 text-sm text-green-700 font-mono text-right">{formatCurrency(row.amountB)}</td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
                <div className="p-3 bg-gray-50 border-t border-gray-200">
                     <p className="text-xs text-gray-500 italic">This summary excludes duplicated items for a clean match/unmatch view. Duplicated data is available in the download report.</p>
                </div>
            </div>
        );
    };


    const FileUpload = ({ label, onFileSelect, required, file, setFile }) => (
        <div className="flex flex-col space-y-2">
            <label className="text-sm font-medium text-gray-700 flex items-center">
                <FileSpreadsheet size={16} className="mr-2" />
                {label} {required && <span className="text-red-500 ml-1">*</span>}
            </label>
            <div className="flex items-center space-x-3">
                <input
                    type="file"
                    id={`file-upload-${label.replace(/\s/g, '-')}`}
                    onChange={onFileSelect}
                    accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel"
                    className="hidden"
                />
                <button
                    onClick={() => document.getElementById(`file-upload-${label.replace(/\s/g, '-')}`).click()}
                    className="px-4 py-2 border border-blue-400 bg-blue-50 text-blue-700 text-sm font-semibold rounded-lg hover:bg-blue-100 transition duration-150 flex items-center shadow-sm"
                    type="button"
                >
                    <Upload size={18} className="mr-2" />
                    {file ? 'Change File' : 'Select File'}
                </button>
                {file && (
                    <span className="text-sm text-gray-600 truncate max-w-[200px] md:max-w-none">
                        {file.name}
                    </span>
                )}
                {file && (
                    <button
                        onClick={() => setFile(null)}
                        className="text-red-500 hover:text-red-700 p-1 rounded-full hover:bg-red-50 transition"
                        title="Remove file"
                        type="button"
                    >
                        <X size={16} />
                    </button>
                )}
            </div>
        </div>
    );

    const ReconciliationApp = () => {
        const [fileA, setFileA] = useState(null);
        const [fileB, setFileB] = useState(null);
        const [step, setStep] = useState(1); // 1: Upload, 2: Loading, 3: Results
        const [loadingMessage, setLoadingMessage] = useState('');
        const [error, setError] = useState(null);
        const [results, setResults] = useState(null);
        const [selectedDownloads, setSelectedDownloads] = useState(['matchedA', 'unmatchedA', 'duplicatedA', 'matchedB', 'unmatchedB', 'duplicatedB', 'summary']);

        const handleFileSelect = useCallback((e, setFile) => {
            const file = e.target.files[0];
            if (file) {
                setFile(file);
            }
        }, []);

        const handleReconcile = useCallback(async () => {
            if (!fileA || !fileB) {
                setError("Please upload both Category A and Category B files.");
                return;
            }
            setError(null);
            setResults(null);
            setStep(2);

            try {
                setLoadingMessage('Parsing Category A data...');
                const dataA = await processFile(fileA, 'A');
                
                setLoadingMessage('Parsing Category B data...');
                const dataB = await processFile(fileB, 'B');

                setLoadingMessage('Running layered ID reconciliation...');
                // Simulate a delay for complex calculation visualization
                await new Promise(resolve => setTimeout(resolve, 500)); 
                
                const reconciliationResults = calculateReconciliation(dataA, dataB);
                
                setResults(reconciliationResults);
                setStep(3);
                setLoadingMessage('');

            } catch (err) {
                console.error("Reconciliation Error:", err);
                setError(err.message || "An unknown error occurred during reconciliation.");
                setStep(1);
                setLoadingMessage('');
            }
        }, [fileA, fileB]);

        const toggleDownloadSelection = (id) => {
            setSelectedDownloads(prev => 
                prev.includes(id) 
                    ? prev.filter(item => item !== id) 
                    : [...prev, id]
            );
        };

        const downloadIsDisabled = !results || selectedDownloads.length === 0;

        const downloadOptions = [
            { id: 'matchedA', label: 'Category A Matched (A-side data)' },
            { id: 'unmatchedA', label: 'Category A Unmatched' },
            { id: 'duplicatedA', label: 'Category A Duplicated IDs' },
            { id: 'matchedB', label: 'Category B Matched (B-side data)' },
            { id: 'unmatchedB', label: 'Category B Unmatched' },
            { id: 'duplicatedB', label: 'Category B Duplicated IDs' },
            { id: 'summary', label: 'Combined Summary Sheet' },
        ];


        // Use a key to reset selectedDownloads when results change (e.g., new upload)
        useEffect(() => {
            if (results) {
                 setSelectedDownloads(downloadOptions.map(o => o.id)); // Select all by default on successful result
            }
        }, [results]);


        const header = (
            <header className="py-6 bg-white border-b border-gray-200 shadow-sm">
                <div className="max-w-6xl mx-auto px-4 sm:px-6 lg:px-8">
                    <h1 className="text-3xl font-extrabold text-gray-900 flex items-center">
                        <FileSpreadsheet size={30} className="text-indigo-600 mr-3" />
                        Advanced Reconciliation Tool
                    </h1>
                    <p className="mt-1 text-sm text-gray-500">
                        Layered ID extraction and two-category (A vs B) matching with detailed reporting.
                    </p>
                </div>
            </header>
        );

        return (
            <div className="min-h-screen bg-gray-50">
                {header}
                <div className="max-w-6xl mx-auto py-8 sm:px-6 lg:px-8">
                    {/* Error Message Display */}
                    {error && (
                        <div className="mb-6 p-4 bg-red-100 border-l-4 border-red-500 text-red-700 rounded-lg flex items-center">
                            <X size={20} className="mr-3 flex-shrink-0" />
                            <p className="font-semibold">Error: {error}</p>
                        </div>
                    )}

                    {/* Step 1: Upload Files */}
                    {step === 1 && (
                        <div className="bg-white shadow-xl rounded-xl p-8 space-y-6 border border-gray-200">
                            <h2 className="text-2xl font-bold text-gray-800 border-b pb-3 mb-4">Step 1: Upload Files</h2>
                            <div className="grid md:grid-cols-2 gap-6">
                                <FileUpload 
                                    label="Category A File (e.g., General Ledger)" 
                                    onFileSelect={(e) => handleFileSelect(e, setFileA)}
                                    required={true}
                                    file={fileA}
                                    setFile={setFileA}
                                />
                                <FileUpload 
                                    label="Category B File (e.g., Bank Statement)" 
                                    onFileSelect={(e) => handleFileSelect(e, setFileB)}
                                    required={true}
                                    file={fileB}
                                    setFile={setFileB}
                                />
                            </div>
                            <div className="pt-4 border-t">
                                <button
                                    onClick={handleReconcile}
                                    disabled={!fileA || !fileB}
                                    className={`w-full px-6 py-3 font-semibold rounded-lg transition duration-200 flex items-center justify-center ${
                                        (fileA && fileB) ? 'bg-indigo-600 text-white hover:bg-indigo-700 shadow-md' : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                                    }`}
                                >
                                    <Check size={20} className="mr-2" />
                                    Run Reconciliation
                                </button>
                                <p className="mt-3 text-xs text-gray-500 text-center">
                                    Files must contain 'Narration', 'Debit', 'Credit', and 'UniqueRef' columns.
                                </p>
                            </div>
                        </div>
                    )}

                    {/* Step 2: Loading State */}
                    {step === 2 && (
                        <div className="bg-white shadow-xl rounded-xl p-8 flex flex-col items-center justify-center space-y-4 border border-gray-200">
                            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600"></div>
                            <p className="text-lg font-semibold text-indigo-600">Processing...</p>
                            <p className="text-gray-500">{loadingMessage}</p>
                        </div>
                    )}

                    {/* Step 3: Results Display */}
                    {step === 3 && results && (
                        <div className="space-y-8">
                            
                            {/* Simple Summary Table (Requirement: Matched, Unmatched, Total side-by-side) */}
                            <SimpleSummaryDisplay results={results} />

                            {/* Download Selection and Button */}
                            <div className="bg-white shadow-xl rounded-xl p-6 border border-gray-200 space-y-4">
                                <h3 className="text-xl font-bold text-gray-800">Step 2: Download Reports</h3>
                                <p className="text-sm text-gray-600">Select the detailed reports you wish to include in the final Excel file. The file will contain one sheet per selected item.</p>
                                
                                {/* Checkbox Grid for Selection */}
                                <div className="grid sm:grid-cols-2 lg:grid-cols-3 gap-3 p-4 bg-gray-50 rounded-lg border border-gray-200">
                                    {downloadOptions.map((option) => (
                                        <label key={option.id} className="flex items-center space-x-2 text-sm text-gray-700 cursor-pointer">
                                            <input
                                                type="checkbox"
                                                checked={selectedDownloads.includes(option.id)}
                                                onChange={() => toggleDownloadSelection(option.id)}
                                                className="form-checkbox h-4 w-4 text-indigo-600 rounded border-gray-300 focus:ring-indigo-500"
                                            />
                                            <span className={`transition duration-150 ${selectedDownloads.includes(option.id) ? 'font-semibold' : 'font-normal'}`}>{option.label}</span>
                                        </label>
                                    ))}
                                </div>


                                <button
                                    onClick={() => downloadReport(results, selectedDownloads)}
                                    disabled={downloadIsDisabled}
                                    className={`w-full px-6 py-3 font-bold rounded-lg transition duration-200 flex items-center justify-center shadow-lg ${
                                        !downloadIsDisabled ? 'bg-indigo-600 text-white hover:bg-indigo-700' : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                                    }`}
                                >
                                    <FileDown size={20} className="mr-2" />
                                    Download ({selectedDownloads.length}) Report{selectedDownloads.length !== 1 ? 's' : ''} as Excel File
                                </button>
                            </div>
                            
                            <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                                <p className="text-sm text-blue-800 flex items-start">
                                    <Info size={18} className="mr-2 mt-0.5 flex-shrink-0 text-blue-600" />
                                    <span>
                                        **Traceability Note:** All downloaded data sheets include essential metadata like **`Composite_ID`** (the match key), **`Source_File`**, and **`Original_Row_Index`** (for the exact row number in the source file) to help you trace the transaction back to its origin.
                                    </span>
                                </p>
                            </div>
                            <div className="text-center pt-4">
                                <button 
                                    onClick={() => setStep(1)} 
                                    className="px-6 py-3 border border-gray-300 text-gray-700 font-semibold rounded-lg hover:bg-gray-100 transition duration-200"
                                >
                                    Start New Reconciliation
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            </div>
        );
    };
    
    // Render the React application
    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    root.render(<ReconciliationApp />);

    </script>
</body>
</html>
